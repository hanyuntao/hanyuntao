<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js里函数调用的四种模式]]></title>
    <url>%2F2017%2F04%2F29%2Fjs%E9%87%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[js 里函数调用有4种模式：方法调用、正常函数调用、构造器函数调用、apply/call调用。同时，无论哪种函数调用除了你声明时定义的形参外，还会自动添加2个形参，分别是this 和 arguments。 1.方法调用这个很好理解，函数是一个对象的属性，比如1234567var a = &#123; v : 0, f : function(xx) &#123; this.v = xx; &#125;&#125;a.f(5); 这个时候，上面函数里的 this 就绑定的是这个对象 a。所以this.v 可以取到对象a 的属性 v。 2.正常函数调用：依然看代码1234function f(xx) &#123; this.x = xx;&#125;f(5); 这个时候，函数 f里的this 绑定的是全局对象，如果是在浏览器运行的解释器中，一般来说是楼上说的 window对象。所以这里 this.x访问的其实是 window.x，当然，如果 window没有 x 属性，那么你这么一写，按照 js 的坑爹语法，就是给 window 对象添加了一个 x 属性，同时赋值。 3.构造器函数调用：构造函数一直是我认为是 js 里最坑爹的部分，因为它和 js 最初设计的基于原型的面向对象实现方式格格不入，就好像是特意为了迎合大家已经被其他基于类的面相对象实现给惯坏了的习惯。如果你在一个函数前面带上 new关键字来调用，那么 js 会创建一个prototype属性是此函数的一个新对象，同时在调用这个函数的时候，把this绑定到这个新对象上。当然new 关键字也会改变return语句的行为。看代码1234function a(xx) &#123; this.m = xx;&#125;var b = new a(5); 上面这个函数和正常调用的函数写法上没什么区别，只不过在调用的时候函数名前面加了关键字new 罢了，这么一来，this 绑定的就不再是前面讲到的全局对象了，而是这里说的创建的新对象，所以说这种方式其实很危险，因为光看函数，你不会知道这个函数到底是准备拿来当构造函数用的，还是一般函数用的，所以我们可以看到，在jslint里，它会要求你写的所有构造函数，也就是一旦它发现你用了 new关键字，那么后面那个函数的首字母必须大写，这样通过函数首字母大写的方式来区分，我个人只有一个看法：坑爹：） 4.apply/call 调用： 我们知道，在 js 里，函数其实也是一个对象，那么函数自然也可以拥有它自己的方法，有点绕，就好像函数可以自己有属性也是一个函数。其中每个函数都拥有apply()这个方法，让我们构造一个参数数组传递给函数，同时可以自己来设置this 的值，这就是它最强大的地方，上面的3种函数调用方法，你可以看到，this 都是自动绑定的，没办法由你来设，当你想设的时候，就可以用 apply()了。apply接收2个参数，第一个是将传递给这个函数的 this的值，第二个是参数数组。看代码：1234567function a(xx) &#123; this.b = xx;&#125;var o = &#123;&#125;;a.apply(o, [5]);alert(a.b); // undefinedalert(o.b); // 5 是不是很神奇，函数 a居然可以给o 加属性值。当然，如果你 apply的第一个参数传递 null，那么在函数a 里面 this 指针依然会绑定全局对象。你可能要问了，apply 函数是哪来的，因为在 js 里所有的函数都有一个共同的prototype，也就是传说中的 Function.prototype, 这个原型里有两个神奇的方法，一个就是这里的apply ，另一个就是让题主疑惑的 call。call()方法和 apply() 方法很类似，它们的存在都是为了改变this 的绑定，那call() 和 apply() 有什么区别呢？就我个人看来，没啥鸟区别。。。开玩笑！刚刚说了，上面 apply()接收两个参数，第一个是你想要 this 绑定的对象，第二个是一个参数数组，注意是一个数组，你想传递给这个函数的所有内容都放在数组里，然后 apply() 函数会在传递形参时自动帮你展开，同时加入我上面提到的另一个神奇形参arguments。而 call() 呢，它的第一个参数也是你想要this 绑定的对象，但是后面可以接受不定参数，而不再是一个数组，也就是你可以像平时给函数传参那样把这些参数一个一个传递，当然，神奇形参 arguments还是不会少的。所以如果一定要说有什么区别的话，看起来是这样的1234567function a(xx, yy) &#123; alert(xx, yy); alert(this); alert(arguments);&#125;a.apply(null, [5, 55]);a.call(null, 5, 55); 仅此而已。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么html里面的onclick函数后面要加()，而js里面不需要？]]></title>
    <url>%2F2017%2F04%2F21%2F%E4%B8%BA%E4%BB%80%E4%B9%88html%E9%87%8C%E9%9D%A2%E7%9A%84onclick%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E8%A6%81%E5%8A%A0-%EF%BC%8C%E8%80%8Cjs%E9%87%8C%E9%9D%A2%E4%B8%8D%E9%9C%80%E8%A6%81%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天在自学的时候碰见了一个奇怪的事情，先给大家列出几个例子，大家猜猜结果。才疏学浅，有错误请一定指出，首先谢谢您的支持！ 示例1js代码123function fn() &#123; alert(&quot;hello&quot;);&#125; html代码1&lt;button onclick=&quot;fn()&quot;&gt;hello&lt;/button&gt; 示例2js代码123function fn() &#123; alert(&quot;hello&quot;);&#125; html代码1&lt;button onclick=&quot;fn&quot;&gt;hello&lt;/button&gt; 示例3js代码1234function fn() &#123; alert(&quot;hello&quot;);&#125;document.getElementsByTagName(&quot;button&quot;)[0].onclick=fn(); html代码1&lt;button&gt;hello&lt;/button&gt; 示例4js代码1234function fn() &#123; alert(&quot;hello&quot;);&#125;document.getElementsByTagName(&quot;button&quot;)[0].onclick=fn; html代码1&lt;button&gt;hello&lt;/button&gt; 答案： 示例1点击弹出“hello”； 示例2点击没反应； 示例3不用点击，直接弹出“hello”； 示例4点击弹出“hello”。 为什么会出现这种情况呢？ 首先要记住，fn()会执行，而fn是不执行的。 当在html里面写onclick的时候（示例1），实际上fn()是在一个onclick函数里面：1function onclick()&#123; fn(); &#125; 所以当你点击按钮的时候，onclick函数会执行，然后onclick里面的是fn()，所以执行onclick函数的时候，fn函数也执行了，但是像示例2中onclick=&quot;fn&quot;的话，就是function onclick(){ fn }，这样就算执行了onclick，fn也就不会执行了。 当写在js代码里面的时候，onclick实际上就是你赋值的那个函数，在示例3代码里面，onclick就是fn函数，所以当你触发onclick的时候（点击button时），onclick执行（onclick变成onclick()即fn变成fn()），其实就是fn函数执行。如果你换成fn()，不用点击button，onclick直接变成了onclick()所以直接弹出“hello”。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式实用总结]]></title>
    <url>%2F2017%2F04%2F20%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、什么是正则表达式正则表达式是由一个字符序列形成的搜索模式，搜索模式可用于文本搜索和文本替换。 二、创建正则表达式JS正则表达式的创建有两种方式： new RegExp() 和 直接字面量。123456var re=new RegExp ();//RegExp 是JS中的类，同Array类似。然而这个创建方法没有指定表达式内容re=new RegExp (&quot;a&quot;);//最简单的正则表达式，将匹配字母a re=new RegExp (&quot;a&quot;,&quot;i&quot;);//重载的构造函数，其第二个参数指定将不区分大小写 其中，对于第二个参数，为可选参数，包括三种： g：全文查找； i：不区分大小写； m：多行查找； 然而更为常见的正则表达式创建法则是：字面量的声明方式。 即：12var re=/a/i;//其作用同：re=new RegExp (&quot;a&quot;,&quot;i&quot;)，而且更常用。 三、正则表达式本身的方法在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。 test() 方法test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回true，否则返回 false。1234//以下实例用于搜索字符串中的字符 &quot;e&quot;：var patt = /e/;patt.test(&quot;The best things in life are free!&quot;);字符串中含有 &quot;e&quot;，所以该实例输出为：true 12以上两行代码可以合并为一行：/e/.test(&quot;The best things in life are free!&quot;) exec() 方法exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。以下实例用于搜索字符串中的字母 e:123/e/.exec(&quot;The best things in life are free!&quot;);字符串中含有 &quot;e&quot;，所以该实例输出为:e 比较常用的就是正则表达式的test方法了，因为大多只需要知道：某个字符串是否匹配某正则表达式，是则True，否则为False。 四、字符串对象中与正则表达式有关的方法在 JavaScript 中，正则表达式通常用于两个字符串方法 : search()和 replace()。 search() 方法 检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 12345//使用正则表达式搜索 &quot;Runoob&quot; 字符串，且不区分大小写：var str = &quot;Visit Runoob!&quot;; var n = str.search(/Runoob/i);//输出结果为：6 用于检索字符串中指定的子字符串。search方法可使用字符串作为参数。字符串参数会转换为正则表达式： 123//检索字符串中 &quot;Runoob&quot; 的子串：var str = &quot;Visit Runoob!&quot;; var n = str.search(&quot;Runoob&quot;); replace() 方法replace() 方法将接收字符串作为参数： 123456var str=&quot;Visit W3CSchool!&quot;;var n=str.replace(&quot;W3CSchool&quot;,&quot;Runoob&quot;);console.log(n);//结果Visit Runoob!console.log(str);//结果Visit W3CSchool! 五、常用语法分析5.1 ()、[]、{} 的区别先看个例子校验字符串是否全由8位数字组成1234function isStudentNo(str) &#123; var reg=/^[0-9]&#123;8&#125;$/; /*定义验证表达式*/ return reg.test(str); /*进行验证*/&#125; []是定义匹配的字符范围。[0-9]表示查找任何从 0 至 9 的数字。 {} 一般用来表示匹配的长度。{8}表示位数为8位。 () 的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如(\s+)表示连续空格的字符串。 5.2 ^ 和 $^ 匹配一个字符串的开头，比如 (^a) 就是匹配以字母a开头的字符串 $ 匹配一个字符串的结尾,比如 (b$) 就是匹配以字母b结尾的字符串 ^还有另个一个作用就是取反，比如[^xyz]表示匹配的字符串不包含xyz 需要注意的是：如果^出现在[]中一般表示取反，而出现在其他地方则是匹配字符串的开头。 5.3 \d \s \w .\d 匹配一个非负整数， 等价于 [0-9]； \s 匹配一个空白字符； \w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]； . 匹配除换行符以外的任意字符，等价于[^\n]。 5.4 * + ?*表示匹配前面元素0次或多次，比如(\s*)就是匹配0个或多个空格； + 表示匹配前面元素1次或多次，比如(\d+)就是匹配由至少1个整数组成的字符串； ?表示匹配前面元素0次或1次，相当于{0,1}，比如(\w?) 就是匹配最多由1个字母或数字组成的字符串 。 六、语法大全修饰符修饰符用于执行区分大小写和全局匹配: 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 `[^adgk ]` 查找给定集合外的任何字符。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \w 查找单词字符。 \W 查找非单词字符。 \d 查找数字。 \D 查找非数字字符。 \s 查找空白字符。 \S 查找非空白字符。 \b 匹配单词边界。 \B 匹配非单词边界。 \0 查找 NULL 字符。 \n 查找换行符。 \f 查找换页符。 \r 查找回车符。 \t 查找制表符。 \v 查找垂直制表符。 \xxx 查找以八进制数 xxx 规定的字符。 \xdd 查找以十六进制数 dd 规定的字符。 \uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n的字符串。例如，/a+/ 匹配 candy中的 a，caaaaaaandy 中所有的a。 n* 匹配任何包含零个或多个 n 的字符串。例如，/bo*/匹配 A ghost booooed 中的 boooo，A bird warbled 中的 b，但是不匹配 A goat grunted。 n? 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 angel 中的 el，angle 中的 le。 n{X} 匹配包含X 个n的序列的字符串。例如，/a{2}/不匹配 candy, 中的 a，但是匹配 caandy, 中的两个 a，且匹配 caaandy. 中的前两个 a。 n{X,} X 是一个正整数。前面的模式 n 连续出现至少X 次时匹配。例如，/a{2,}/不匹配 candy 中的 a，但是匹配 caandy 和 caaaaaaandy. 中所有的 a。 n{X,Y} X和 Y 为正整数。前面的模式n 连续出现至少 X次，至多 Y次时匹配。例如，/a{1,3}/ 不匹配 cndy，匹配 candy, 中的 a，caandy, 中的两个 a，匹配 caaaaaaandy 中的前面三个 a。注意，当匹配 caaaaaaandy 时，即使原始字符串拥有更多的 a，匹配项也是 aaa。 n{X,} 匹配包含至少 X 个n 的序列的字符串。 n$ 匹配任何结尾为 n的字符串。 ^n 匹配任何开头为n的字符串。 ?=n 匹配任何其后紧接指定字符串n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 七、12个常用的js正则表达式 在input框中只能输入金额，其实就是只能输入最多有两位小数的数字 12345678//第一种在input输入框限制 &lt;input type=&quot;text&quot; maxlength=&quot;8&quot; class=&quot;form-control&quot; id=&quot;amount&quot; style=&quot;margin-right: 2px;&quot; value=&quot;&quot; onChange=&quot;count();&quot; onkeyup=&quot;if (this.value==this.value2) return; if (this.value.search(/^\d*(?:\.\d&#123;0,2&#125;)?$/)==-1) this.value=(this.value2)?this.value2:&apos;&apos;;else this.value2=this.value;&quot;&gt;元//第二种对于表单动态增加的方式，只能在js方法中验证。 var amount=$(&quot;#amount&quot;).val(); if (amount.search(/^\d*(?:\.\d&#123;0,2&#125;)?$/)==-1) &#123; alert(&quot;金额格式不对，最多有两位小数&quot;); return false;&#125; 验证邮箱格式 123456var reg=/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/; var email=$(&quot;#email&quot;).val(); if(!reg.test(email) )&#123; alert(&quot;请输入符合规范的邮箱账号！&quot;); return false; &#125; 密码采用数字、字母、特殊字符且长度为8-20位 1234567function validatePwd(str) &#123;if (/^.*?[\d]+.*$/.test(str) &amp;&amp; /^.*?[A-Za-z]/.test(str)&amp;&amp; /^.*?[~/`!@#$%^&amp;*()_+|&#123;&#125;?;:&gt;&lt;\-\]\\[\/].*$/.test(str) &amp;&amp; /^.&#123;8,20&#125;$/.test(str)) &#123;return true;&#125;return false;&#125; 验证电话号码 12345678910/** * 验证电话号码 * @param phoneValue 要验证的电话号码 * @returns 匹配返回true 不匹配返回false */function validatePhone(phoneValue) &#123; phoneValue = valueTrim(phoneValue); var reg = /^[1][0-9]&#123;10&#125;$/; return reg.test(phoneValue);&#125; 判断是否是汉字 1234567891011/** * 判断是否是汉字 * * @param charValue * 要验证的数据 * @returns 匹配返回true 不匹配返回false */function isCharacter(charValue) &#123; var reg = /^[\u4e00-\u9fa5]&#123;0,&#125;$/; return reg.test(charValue);&#125; 是否为字母:true:是，false:不是 12345function isChar(charValue)&#123; var charPattern=/^[a-zA-Z]*$/; //是否为字母 result=charPattern.test(charValue); return result;&#125; 判断是否为数字 12345function isNum(numValue)&#123; var numPattern=/^\d*$/; //数字的正则表达式 result=numPattern.test(numValue); return result;&#125; 整数的正则表达式 12345function isInt(intValue)&#123; var intPattern=/^0$|^[1-9]\d*$/; //整数的正则表达式 result=intPattern.test(intValue); return result; &#125; 是否为字母和数字 12345function isCharNum(flagValue)&#123; var flagPattern=/^[a-zA-Z0-9]*$/; //是否为字母和数字 result=flagPattern.test(flagValue); return result;&#125; 检验18位身份证号码 12345678910111213141516171819202122232425/** * 检验18位身份证号码（15位号码可以只检测生日是否正确即可，自行解决） * * @param idCardValue * 18位身份证号 * @returns 匹配返回true 不匹配返回false */function idCardVildate(cid) &#123;var arrExp = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ];// 加权因子var arrValid = [ 1, 0, &quot;X&quot;, 9, 8, 7, 6, 5, 4, 3, 2 ];// 校验码var reg = /^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;([0-9]|X)$/;if (reg.test(cid)) &#123;var sum = 0, idx;for (var i = 0; i &lt; cid.length - 1; i++) &#123;// 对前17位数字与权值乘积求和sum += parseInt(cid.substr(i, 1), 10) * arrExp[i];&#125;// 计算模（固定算法）idx = sum % 11;// 检验第18为是否与校验码相等return arrValid[idx] == cid.substr(17, 1).toUpperCase();&#125; else &#123;return false;&#125;&#125; 验证15位数身份证号码中的生日是否是有效生日 1234567891011121314function isValidityBrithBy15IdCard(idCard15) &#123; var year = idCard15.substring(6, 8); var month = idCard15.substring(8, 10); var day = idCard15.substring(10, 12); var temp_date = new Date(year, parseFloat(month) - 1, parseFloat(day)); // 对于老身份证中的你年龄则不需考虑千年虫问题而使用getYear()方法 if (temp_date.getYear() != parseFloat(year) || temp_date.getMonth() != parseFloat(month) - 1 || temp_date.getDate() != parseFloat(day)) &#123; return false; &#125; else &#123; return true; &#125;&#125; 验证18位数身份证号码中的生日是否是有效生日 1234567891011121314function isValidityBrithBy18IdCard(idCard18) &#123; var year = idCard18.substring(6, 10); var month = idCard18.substring(10, 12); var day = idCard18.substring(12, 14); var temp_date = new Date(year, parseFloat(month) - 1, parseFloat(day)); // 这里用getFullYear()获取年份，避免千年虫问题 if (temp_date.getFullYear() != parseFloat(year) || temp_date.getMonth() != parseFloat(month) - 1 || temp_date.getDate() != parseFloat(day)) &#123; return false; &#125; else &#123; return true; &#125;&#125; 参考资料：JS中正则表达式概述JS正则表达式常用总结12个常用的js正则表达式JavaScript RegExp 对象]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS产生随机数]]></title>
    <url>%2F2017%2F04%2F19%2FJS%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Math.random(); 结果为0-1间的一个随机数(包括0,不包括1) Math.floor(num); 参数num为一个数值，函数结果为num的整数部分。 Math.round(num); 参数num为一个数值，函数结果为num四舍五入后的整数。 Math.ceil(n); 返回大于等于n的最小整数。 用Math.ceil(Math.random()*10);时，主要获取1到10的随机整数，取0的几率极小。 用Math.round(Math.random());可均衡获取0到1的随机整数。 用Math.round(Math.random()*10);时，可基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。 用Math.floor(Math.random()*10);时，可均衡获取0到9的随机整数。 用Math.floor(Math.random()*50+50);时，可均衡获取50到100的随机整数。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你遇到过[-]-slice-call()吗？]]></title>
    <url>%2F2017%2F04%2F19%2F%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87-slice-call-%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[先放结论：[].slice.call(arguments)能将具有length属性的对象转成数组。 1、基础知识 .slice()方法 定义和用法slice(start, end) 方法可提取数组的某个部分，并以新的数组返回被提取的部分。使用start（包含） 和 end（不包含） 参数来指定提取数组开始和结束的部分。 如果未指定start和end，则返回整个数组。 如果指指定一个参数，该参数作为start使用，返回包括start位置之后的全部数组。 如果是负数，则该参数规定的是从数组的尾部开始算起的位置。也就是说，-1 指数组的最后一项，-2 指倒数第二个项，以此类推。 实例 12345//在数组中读取元素：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(-3,-1);citrus 结果输出:[&quot;Lemon&quot;, &quot;Apple&quot;] .call()方法 定义和用法call()函数用于调用当前函数functionObject，并可同时使用指定对象thisObj作为本次执行时functionObject函数内部的this指针引用。 实例12345678var obj = &#123;name: &quot;李四&quot;, age: 20&#125;;function foo(a, b)&#123; document.writeln(this.name); document.writeln(a); document.writeln(b); &#125;// 改变this引用为obj，同时传递两个参数foo.call(obj, 12, true); // 李四 12 true 2.进入正题当我看到var args = [].slice.call(arguments, 0);这种写法的时候是一脸懵逼的（黑人问号脸）。arguments是一个对象而不是数组，最多算是一个伪数组，而且自身的原型链上也没有slice这个方法。123456789/*确定arguments的类型 * 返回 3,Object, true; */ (function(a,b,c)&#123; console.log(arguments.length); console.log(typeof arguments); console.log( arguments instanceof Object); &#125;(1,2,3)) [].slice.call(arguments)能将具有length属性的对象转成数组： []自身也是也是一个对象.而数组原型链上有这个slice这个方法。 12/*此处的返回值是true*/ [].slice === Array.prototype.slice; 通过call显式绑定来实现arguments变相有slice这个方法。 这就是说：Array.prototype.slice.call(arguments,0)这句里，就是把 arguments 当做当前对象 也就是说 要调用的是 arguments 的slice 方法，后面的 参数 0 也就成了 slice 的第一个参数，slice(0)就是获取所有。 补充： 将函数的实际参数转换成数组的方法 方法一：var args = Array.prototype.slice.call(arguments); 方法二：var args = [].slice.call(arguments, 0); 方法三：1234var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 最后，附个转成数组的通用函数1234567891011121314var toArray = function(s)&#123; //try语句允许我们定义在执行时进行错误测试的代码块。 //catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 try&#123; return Array.prototype.slice.call(s); &#125; catch(e)&#123; var arr = []; for(var i = 0,len = s.length; i &lt; len; i++)&#123; //arr.push(s[i]); arr[i] = s[i]; //据说这样比push快 &#125; return arr; &#125;&#125; 参考资料：Array.prototype.slice.call()方法详解 对[].slice.call(arguments,1) 的一丢丢见解JavaScript arguments对象JavaScript Function.call() 函数详解]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵活方便的布局方式——弹性布局]]></title>
    <url>%2F2017%2F04%2F18%2F%E7%81%B5%E6%B4%BB%E6%96%B9%E4%BE%BF%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[本篇文章全部摘自阮一峰老师的Flex 布局教程。 之前我一直在用布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。最近在做百度前端技术学院的作业时发现很多人都在用Flex 布局，简单几行代码就能实现特殊的布局，所以我找了点资料，开始学习弹性布局。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。因为一山不容二虎，float、clear和vertical-align属性都是用来布局的属性，一旦使用flex，原来这些古老的属性不失效还留着干什么？ 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。各属性演示地址123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴（垂直轴）上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。1.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。1.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。1.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。1.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow,flex-shrink和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。1.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。1.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 五、Flex布局实例链接5.1 骰子的布局 5.2 网格布局 5.3 圣杯布局 5.4 输入框的布局 5.5 悬挂式布局 5.6 固定的底栏 5.7 流式布局]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种基础的排序算法]]></title>
    <url>%2F2017%2F04%2F17%2F%E4%B8%89%E7%A7%8D%E5%9F%BA%E7%A1%80%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在计算机科学所使用的排序算法通常被分类为： 计算的 时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，且坏的性能是O(n^2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。 存储器使用量（以及其他电脑资源的使用）稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 依据排序的方法：插入、交换、选择、合并等等。 依据排序的方法分类的三种排序算法: 冒泡排序冒泡排序对一个需要进行排序的数组进行以下操作: 比较第一项和第二项; 如果第一项应该排在第二项之后, 那么两者交换顺序; 比较第二项和第三项; 如果第二项应该排在第三项之后, 那么两者交换顺序; 以此类推直到完成排序; 实例说明: 将数组[3, 2, 4, 5, 1]以从小到大的顺序进行排序: 3应该在2之后, 因此交换, 得到[2, 3, 4, 5, 1]; 3, 4顺序不变, 4, 5也不变, 交换5, 1得到[2, 3, 4, 1, 5]; 第一次遍历结束, 数组中最后一项处于正确位置不会再有变化, 因此下一次遍历可以排除最后一项; 开始第二次遍历, 最后结果为[2, 3, 1, 4, 5], 排除后两项进行下一次遍历; 第三次遍历结果为[2, 1, 3, 4, 5]; 最后得到[1, 2, 3, 4, 5], 排序结束; 代码实现:12345678910111213141516function swap(items, firstIndex, secondIndex)&#123; var temp = items[firstIndex]; items[firstIndex] = items[secondIndex]; items[secondIndex] = temp;&#125;;function bubbleSort(items)&#123; var len = items.length, i, j, stop; for (i = 0; i &lt; len; i++)&#123; for (j = 0, stop = len-i; j &lt; stop; j++)&#123; if (items[j] &gt; items[j+1])&#123; swap(items, j, j+1); &#125; &#125; &#125; return items;&#125; 外层的循环决定需要进行多少次遍历, 内层的循环负责数组内各项的比较, 还通过外层循环的次数和数组长度决定何时停止比较. 冒泡排序极其低效, 因为处理数据的步骤太多, 对于数组中的每n项, 都需要n^2次操作来实现该算法(实际比n^2略小, 但可以忽略, 具体原因见⤵️), 即时间复杂度为O(n^2). 对于含有n个元素的数组, 需要进行(n-1)+(n-2)+...+1次操作, 而(n-1)+(n-2)+...+1 = n(n-1)/2 = n^2/2 - n/2, 如果n趋于无限大, 那么n/2的大小对于整个算式的结果影响可以忽略, 因此最终的时间复杂度用O(n^2)表示 选择排序选择排序对一个需要进行排序的数组进行以下操作: 1.假定数组中的第一项为最小值(min); 比较第一项和第二项的值; 若第二项比第一项小, 则假定第二项为最小值; 以此类推直到排序完成. 实例说明: 将数组[&quot;b&quot;, &quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;e&quot;]以字母a-z的顺序进行排序: 假定数组中第一项&quot;b&quot;(index0)为min; 比较第二项”a”与第一项”b”, 因”a”应在”b”之前的顺序, 故&quot;a&quot;(index1)为min; 然后将min与后面几项比较, 由于”a”就是最小值, 因此min确定在index1的位置; 第一次遍历结束后, 将假定的min(index0), 与真实的min(index1)进行比较, 真实的min应该在index0的位置, 因此将两者交换, 第一次遍历交换之后的结果为[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;c&quot;, &quot;e&quot;]; 然后开始第二次遍历, 遍历从第二项(index1的位置)开始, 这次假定第二项为最小值, 将第二项与之后几项逐个比较, 因为”b”就在应该存在的位置, 所以不需要进行交换, 这次遍历之后的结果为[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;c&quot;, &quot;e&quot;];6.之后开始第三次遍历, “c”应为这次遍历的最小值, 交换index2(&quot;d&quot;),index3(&quot;c&quot;)位置, 最后结果为[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]; 最后一次遍历, 所有元素在应有位置, 不需要进行交换. 代码实现:1234567891011121314151617181920212223function swap(items, firstIndex, secondIndex)&#123; var temp = items[firstIndex]; items[firstIndex] = items[secondIndex]; items[secondIndex] = temp;&#125;;function selectionSort()&#123; let items = [...document.querySelectorAll(&apos;.num-queue span&apos;)].map(num =&gt; +num.textContent); let len = items.length, min; for (i = 0; i &lt; len; i++)&#123; min = i; for(j = i + 1; j &lt; len; j++)&#123; if(items[j] &lt; items[min])&#123; min = j; &#125; &#125; if(i != min)&#123; swap(items, i, min); &#125; &#125; return items;&#125;; 外层循环决定每次遍历的初始位置, 从数组的第一项开始直到最后一项. 内层循环决定哪一项元素被比较. 选择排序的时间复杂度为O(n^2). 插入排序与上述两种排序算法不同, 插入排序是稳定排序算法(stable sort algorithm), 稳定排序算法指不改变列表中相同元素的位置, 冒泡排序和选择排序不是稳定排序算法, 因为排序过程中有可能会改变相同元素位置. 对简单的值(数字或字符串)排序时, 相同元素位置改变与否影响不是很大. 而当列表中的元素是对象, 根据对象的某个属性对列表进行排序时, 使用稳定排序算法就很有必要了. 一旦算法包含交换(swap)这个步骤, 就不可能是稳定的排序算法. 列表内元素不断交换, 无法保证先前的元素排列为止一直保持原样. 而插入排序的实现过程不包含交换, 而是提取某个元素将其插入数组中正确位置. 插入排序的实现是将一个数组分为两个部分, 一部分排序完成, 一部分未进行排序. 初始状态下整个数组属于未排序部分, 排序完成部分为空. 然后进行排序, 数组内的第一项被加入排序完成部分, 由于只有一项, 自然属于排序完成状态. 然后对未完成排序的余下部分的元素进行如下操作: 如果这一项的值应该在排序完成部分最后一项元素之后, 保留这一项在原有位置开始下一步; 如果这一项的值应该排在排序完成部分最后一项元素之前, 将这一项从未完成部分暂时移开, 将已完成部分的最后一项元素移后一个位置; 被暂时移开的元素与已完成部分倒数第二项元素进行比较; 如果被移除元素的值在最后一项与倒数第二项的值之间, 那么将其插入两者之间的位置, 否则继续与前面的元素比较, 将暂移出的元素放置已完成部分合适位置. 以此类推直到所有元素都被移至排序完成部分. 实例说明: 现在需要将数组var items = [5, 2, 6, 1, 3, 9];进行插入排序: 5属于已完成部分, 余下元素为未完成部分. 接下来提取出2, 因为5比2大, 于是5被移至靠右一个位置, 覆盖2, 占用2原本存在的位置. 这样本来存放5的位置(已完成部分的首个位置)就被空出, 而2在比5小, 因此将2置于这个位置, 此时结果为[2, 5, 6, 1, 3, 9]; 接下来提取出6, 因为6比5大, 所以不操作提取出1, 1与已完成部分各个元素(2, 5, 6)进行比较, 应该在2之前, 因此2, 5, 6各向右移一位, 1置于已完成部分首位, 此时结果为[1, 2, 5, 6, 3, 9]; 对余下未完成元素进行类似操作, 最后得出结果[1, 2, 3, 5, 6, 9]; 代码实现:1234567891011function insertionSort(items) &#123; let len = items.length, value, i, j; for (i = 0; i &lt; len; i++) &#123; value = items[i]; for (j = i-1; j &gt; -1 &amp;&amp; items[j] &gt; value; j--) &#123; items[j+1] = items[j]; &#125; items[j+1] = value; &#125; return items;&#125;; 外层循环的遍历顺序是从数组的第一位到最后一位, 内层循环的遍历则是从后往前, 内层循环同时负责元素的移位. 插入排序的时间复杂度为O(n^2) 以上三种排序算法都十分低效, 因此实际应用中不要使用这三种算法, 遇到需要排序的问题, 应该首先使用JavaScript内置的方法Array.prototype.sort(); 参考: 2015-CS50-week-算法排序算法-JavaScript描述三种基础的排序算法]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础篇（三）——DOM的各种操作]]></title>
    <url>%2F2017%2F04%2F15%2Fjs%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94DOM%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 什么是DOM 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 2.DOM节点在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 整个html文档就是是一个Document。 所有的HTML元素都是元素节点。 所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。 注释是注释节点。 3. Document 对象 当浏览器载入 HTML 文档, 它就会成为 document对象。 document 对象是HTML文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）。 Document对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window对象的一部分，可通过 window.document属性对其进行访问。 4. Document 对象属性和方法下表是DOM对象的全部属性和方法列表，在列表下面，详细地介绍了常见的原生javascript DOM操作。 属性 / 方法 描述 document.activeElement 返回当前获取焦点元素 document.addEventListener() 向文档添加句柄 document.adoptNode(node) 从另外一个文档返回 adapded节点到当前文档。 document.anchors 返回对文档中所有 Anchor 对象的引用。 document.applets 返回对文档中所有 Applet对象的引用。 document.baseURI 返回文档的绝对基础 URI document.body 返回文档的body元素 document.close() 关闭用 document.open()方法打开的输出流，并显示选定的数据。 document.cookie 设置或返回与当前文档有关的所有 cookie。 document.createAttribute() 创建一个属性节点 document.createComment() createComment()方法可创建注释节点。 document.createDocumentFragment() 创建空的 DocumentFragment 对象，并返回此对象。 document.createElement() 创建元素节点。 document.createTextNode() 创建文本节点。 document.doctype 返回与文档相关的文档类型声明 (DTD)。 document.documentElement 返回文档的根节点 document.documentMode 返回用于通过浏览器渲染文档的模式 document.documentURI 设置或返回文档的位置 document.domain 返回当前文档的域名。 document.domConfig 返回normalizeDocument()被调用时所使用的配置 document.embeds 返回文档中所有嵌入的内容（embed）集合 document.forms 返回对文档中所有 Form对象引用。 document. getElementsByClassName() 返回文档中所有指定类名的元素集合。 document.getElementById() 返回对拥有指定 id 的第一个对象的引用。 document.getElementsByName() 返回带有指定名称的对象集合。 document.getElementsByTagName() 返回带有指定标签名的对象集合。 document.images 返回对文档中所有Image对象引用。 document.implementation 返回处理该文档的 DOMImplementation 对象。 document.importNode() 把一个节点从另一个文档复制到该文档以便应用。 document.inputEncoding 返回用于文档的编码方式（在解析时）。 document.lastModified 返回文档被最后修改的日期和时间。 document.links 返回对文档中所有 Area 和Link对象引用。 document.normalize() 删除空文本节点，并连接相邻节点 document.normalizeDocument() 删除空文本节点，并连接相邻节点的 document.open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 document.querySelector() 返回文档中匹配指定的CSS选择器的第一元素 document.querySelectorAll() document.querySelectorAll()是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 document.readyState 返回文档状态 (载入中……) document.referrer 返回载入当前文档的文档的 URL。 document.removeEventListener() 移除文档中的事件句柄(由 addEventListener()方法添加) document.renameNode() 重命名元素或者属性节点。 document.scripts 返回页面中所有脚本的集合。 document.strictErrorChecking 设置或返回是否强制进行错误检查。 document.title 返回当前文档的标题。 document.URL 返回文档完整的URL document.write() 向文档写 HTML 表达式 或 JavaScript 代码。 document.writeln() 等同于write()方法，不同的是在每个表达式之后写一个换行符。 5. 常见的原生javascript DOM操作5.1 创建元素 创建元素节点：document.createElement()使用document.createElement()可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，在XHTML中区分大小写。1var div = document.createElement(&quot;div&quot;); 此时，新元素尚未被添加到文档树中，因此设置各种特性均不会影响浏览器的显示。要添加到文档树，可用appendChild()、insertBefore()、replaceChild()。（稍后讲到）1document.body.appendChild(div); 当把元素添加到文档树中后，这个元素做的任何修改都会实时地反应到浏览器中。 创建文本节点 ：document.createTextNode()使用document.createTextNode()来创建文本节点，这个方法接受一个参数：要插入节点的文本。与设置已有文本节点的值一样，作为参数的文本将按照HTML或XML的格式进行编码。1document.createTextNode(&quot;121212&quot;); 可以添加多个文本节点。假如两个文本节点是相邻的同胞节点，那么两个文本节点会连起来，中间不会有空格。 5.2 节点关系（IE9以前不将换行和空格看做文本节点，其他浏览器会） 文本关系如下：12345&lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 父节点：parentNodeparentNode是指定节点的父节点。一个元素节点的父节点可能是一个元素(Element )节点，也可能是一个文档(Document)节点，或者是个文档碎片(DocumentFragment)节点。每一个节点都有一个parentNode属性。对于下面的节点类型: Attr, Document，DocumentFragment,Entity, Notation，其parentNode属性返回null。如果当前节点刚刚被建立,还没有被插入到DOM树中，则该节点的parentNode属性也返回null。 12var child2 = document.getElementById(&quot;div2&quot;);var parent = child2.parentNode; 子节点：childNodeschildNodes 返回包含指定节点的子节点的 集合，该集合为即时更新的集合（live collection）。即时更新就是对节点元素的任意修改都会立即反映到结果里。 123456789var child2 = document.getElementById(&quot;div2&quot;);var parent = child2.parentNode;var allChilds = parent.childNodes;console.log(allChilds.length) // IE下是3，其他浏览器是7var nodeAdd = document.createElement(&quot;div&quot;);var textAdd = document.createTextNode(&quot;这是添加的文本节点&quot;);nodeAdd.appendChild(textAdd);parent.appendChild(nodeAdd);console.log(allChilds.length);// IE下是4，其他浏览器是8 兄弟节点：nextSibling，previousSiblingnextSibling返回某节点的下一个兄弟节点，previousSibling返回某节点的上一个兄弟节点，没有的话返回null。注意：可能因为元素换行的原因返回的是text节点。 12345var child3 = document.getElementById(&quot;div3&quot;);var next = child3.nextSibling;var previous = child3.previousSibling;console.log(next); // IE下返回div4，其他返回textconsole.log(previous) // IE下返回div2，其他返回text 第一个或最后一个子节点：firstChild、lastChildfirstChild返回node的子节点中的第一个节点的引用，没有返回nulllastChild返回node的子节点中的最后一个节点的引用，没有返回null1234var child3 = document.getElementById(&quot;div3&quot;);var parent = child3.parentNode;var first = parent.firstChild; // IE是div2，其他是textvar last = parent.lastChild; // IE是div4，其他是text 5.3 节点元素关系只算元素，不算文本节点。 以下三个方法用法和节点关系完全一样，只是这三个方法只看元素节点，不管因为空格、换行造成的文本节点或者手动加上去的文本节点。children： 返回所有 元素子节点（IE5+、ff3.5、opera3、chrome，但在IE8及以下会将注释节点看成一个元素节点） 以下两个IE9+才支持nextElementSibling：返回元素的下一个兄弟元素节点previousElementSibling: 返回元素的上一个兄弟元素节点 5.4 节点操作 appendChild()appendChild()用于向childNodes列表的末尾添加一个节点，并且返回这个新增的节点。如果传入到appendChild()里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。 1234var returnNode = someNode.appendChild(someNode.firstChild);// 返回第一个节点console.log(returnNode === someNode.firstChild); // falseconsole.log(returnNode === someNode.lastChild); // true insetBefore()insetBefore()可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是null，则与appendChild()执行相同的操作。 123456789101112// 插入后成为最后一个子节点var returnNode = someNode.insetBefore(newNode, null);console.log(returnNode === someNode.lastChild); // true// 插入后成为第一个子节点var returnNode = someNode.insetBefore(newNode, someNode.firstChild);console.log(returnNode === newNode); // trueconsole.log(returnNode === someNode.firstChild); // true// 插入到最后一个子节点的前面var returnNode = someNode.insetBefore(newNode, someNode.lastChild);console.log(returnNode === someNode.childNodes[someNode.childnodes.length - 2]) // true 替换节点：replaceChild()replaceChild()接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。 12// 替换第一个子节点var returnNode = someNode.replaceChild(newNode, someNode.firstChild); 使用replaceChild()后，被替换的节点的所有关系指针都会被复制到插入的节点上面。 删除节点：removeChild()该方法移除节点，接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。 12// 移除第一个子节点var returnNode = someNode.removeChild(newNode, someNode.firstChild); 克隆节点：cloneNode(true/false)返回调用该方法的节点的一个副本。参数表示是否采用深度克隆，如果为true，则该节点的所有后代节点也都会被克隆,如果为false，则只克隆该节点本身，文本或者换行、空格这些不会复制，因为他们都是一个textNode。克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=&quot;alert(1)&quot;)，但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。注意:为了防止一个文档中出现两个ID重复的元素,使用cloneNode()方法克隆的节点在需要时应该指定另外一个与原ID值不同的ID 123var div1 = document.getElementById(&quot;div1&quot;);var cloneHtml = div1.cloneNode(true);document.body.appendChild(cloneHtml); 5.5 元素选择HTML代码示例：12345&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;div2&quot; class=&quot;one&quot; name=&quot;nameone&quot;&gt;2&lt;/p&gt; &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt; &lt;div id=&quot;div4&quot; name=&quot;div2&quot;&gt;4&lt;/div&gt;&lt;/div&gt; querySelector返回节点子树内与之相匹配的第一个Element节点。如果没有匹配的节点，则返回null。 querySelectorAll返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表。注意：由 querySelector()、querySelectorAll()返回的节点列表不是动态实时的（非live Collection）。这和其他DOM查询方法返回动态实时节点列表不一样。选择器方法接受一个或多个用逗号分隔的选择器来确定需要被返回的元素。例如，要选择文档中所有CSS的类(class)是warning或者note的段落(p)元素,可以这样写：1var special = document.querySelectorAll( &quot;p.warning, p.note&quot; ); 也可以通过ID来查询，例如：1var el = document.querySelector( &quot;#main, #basic, #exclamation&quot; ); 执行上面的代码后，el就包含了文档中元素的ID是main，basic或exclamation的所有元素中的第一个元素。querySelector() and querySelectorAll()里可以使用任何CSS选择器，他们都不是live Collection：12345var notLive = document.querySelectorAll(&quot;p&quot;);console.log(notLive);document.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));console.log(notLive);// 上面两个输出都是输出 `p#div2.one`的引用，没有因为删除了`p`标签而使`notLive`的结果发生变化。 document.getElementById()方法 12返回指定 ID 的元素：document.getElementById(&quot;demo&quot;); document.getElementsByTagName()方法 12返回带有指定标签名的对象的集合:document.getElementsByTagName(&quot;P&quot;); document.getElementsByName()方法，常用于表单（数组） 12var x=document.getElementsByName(&quot;x&quot;);//x为元素name属性值alert(x.length); getElementsByClassName()方法当在 document对象上调用此方法时，会检索整个文档，包括根元素。(IE9以下不支持)要匹配多个class，则className用空格分开。 1getElementsByClassName(&quot;class1 class2&quot;); 5.6 属性操作 setAttribute()添加一个新属性（attribute）到元素上，或改变元素上已经存在的属性的值。如果指定的属性已经存在，则其值变为传递的值。如果不存在，则创建指定的属性。也可指定为null。如果设置为null，最好使用removeAttribute()。 123var div2 = document.getElementById(&quot;div2&quot;); div2.setAttribute(&quot;class&quot;, &quot;new_class&quot;); div2.setAttribute(&quot;id&quot;, &quot;new_id&quot;); removeAttribute()该方法用于移除元素的属性。 12var div2 = document.getElementById(&quot;div2&quot;);div2.removeAttribute(&quot;class&quot;); getAttribute()该方法返回元素上指定属性（attribute）的值。如果指定的属性不存在，则返回null或&quot;&quot;（空字符串）。 123var div2 = document.getElementById(&quot;div2&quot;);var attr = div2.getAttribute(&quot;class&quot;);console.log(attr); hasAttribute()hasAttribute()返回一个布尔值，指示该元素是否包含有指定的属性（attribute）。 参考资料：常见的原生javascript DOM操作廖雪峰的官方网站]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对二维数组排序]]></title>
    <url>%2F2017%2F04%2F15%2F%E5%AF%B9%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sort()方法怎么使用？sort()方法默认情况下按照升序排列数组项，sort()方法会调用toString()转型方法，然后比较得到的字符串，即使我们比较的是数字，他也会把数字转为字符串以后再排序。请看下面例子： 1234567891011121314var arr1 = [0, 1, 3, 10, 16, 5, 9, 0, 3];var arr2 = [&apos;bangbang&apos;, &apos;father&apos;, &apos;mother&apos;, &apos;brother&apos;, &apos;sister&apos;, true, false, 0, 1, 6, 13];console.log(arr1.sort()) //很明显，这样不是我们要的结果，[ 0, 0, 1, 10, 16, 3, 3, 5, 9 ]console.log(arr2.sort()); //[ 0,1,13,6,&apos;bangbang&apos;,&apos;brother&apos;,false,&apos;father&apos;,&apos;mother&apos;,&apos;sister&apos;,true]//传入自定义回调函数之后function ascend(a,b)&#123; return a-b;&#125;//降序排列function descend(a,b)&#123; return b-a;&#125;console.log(arr1.sort(ascend)); //[ 0, 0, 1, 10, 16, 3, 3, 5, 9 ]console.log(arr1.sort(descend)); //[ 16, 10, 9, 5, 3, 3, 1, 0, 0 ] 用sort方法进行二维数组的排序 123456789var arr1 = [[4,5,7],[11,3,6,100,77],[12,9,12,10],[3,1,2,99,22]];function ascend(x,y)&#123; return x[3] - y[3]; //按照数组的第4个值升序排列&#125;function descend(x,y)&#123; return y[0] - x[0]; //按照数组的第1个值升序排列&#125;console.log(arr1.sort(ascend));console.log(arr1.sort(descend)); 参考资料：JavaScript中用sort方法进行二维数组排序 — 第5.2.5节]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础篇（二）——字符串的各种操作]]></title>
    <url>%2F2017%2F04%2F15%2Fjs%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js基础篇（一）——数组的各种操作js基础篇（三）——DOM的各种操作 1. 创建字符串一个字符串用于存储一系列字符就像&quot;John Doe&quot;。一个字符串可以使用单引号或双引号： 实例123var txt = new String(&quot;string&quot;);//或者更简单方式：var txt = &quot;string&quot;; 2. 访问字符串你使用位置（索引）可以访问字符串中任何的字符： 实例1var character=carname[7]; 字符串的索引从零开始, 所以字符串第一字符为 [0],第二个字符为 [1], 等等。 3. 字符串的属性和方法3.1 属性 属性 描述 constructor 对创建该对象的函数的引用 length 字符串的长度 prototype 允许您向对象添加属性和方法 3.2 方法下面的表格是总结，每个方法的示例在下面。 方法 描述 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接两个或更多字符串，并返回新的字符串。 fromCharCode() 将 Unicode 编码转为字符。 indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。 lastIndexOf() 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 match() 查找找到一个或多个正则表达式的匹配。 replace() 在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。 search() 查找与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 trim() 去除字符串两边的空白 valueOf() 返回某个字符串对象的原始值。 charAt()方法 定义和用法charAt() 方法可返回指定位置的字符。第一个字符位置为 0, 第二个字符位置为 1,以此类推. 实例12345返回字符串中的第三个字符:var str = &quot;HELLO WORLD&quot;;var n = str.charAt(2)n输出结果:L charCodeAt()方法 定义和用法charCodeAt()方法可返回指定位置的字符的 Unicode 编码。字符串中第一个字符的位置为 0， 第二个字符位置为 1，以此类推。 实例12345返回字符串第一个字符的 Unicode 编码:var str = &quot;HELLO WORLD&quot;;var n = str.charCodeAt(0);n 输出结果:72 concat()方法 定义和用法concat() 方法用于连接两个或多个字符串。该方法没有改变原有字符串，但是会返回连接两个或多个字符串新字符串。 实例123456连接两个字符串:var str1 = &quot;Hello &quot;;var str2 = &quot;world!&quot;;var n = str1.concat(str2);n 输出结果:Hello world! fromCharCode()方法 定义和用法fromCharCode()可接受一个指定的 Unicode 值，然后返回一个字符串。注意：该方法是 String 的静态方法，字符串中的每个字符都由单独的 Unicode 数字编码指定。 实例1234将 Unicode 编码转为一个字符:var n = String.fromCharCode(65);n 输出结果:A indexOf()方法 定义和用法indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。注意： indexOf()方法区分大小写。提示： 同样你可以查看类似方法lastIndexOf() 。 实例12345查找字符串 &quot;welcome&quot;:var str=&quot;Hello world, welcome to the universe.&quot;;var n=str.indexOf(&quot;welcome&quot;);n 输出结果:13 lastIndexOf()方法 定义和用法lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置。如果没有找到匹配字符串则返回 -1 。注意：lastIndexOf()方法是区分大小写的！提示： 你也可以参照类似方法indexOf() 。 实例12345查找字符串 &quot;runoob&quot; 最后出现的位置:var str=&quot;I am from runoob，welcome to runoob site.&quot;;var n=str.lastIndexOf(&quot;runoob&quot;);n 输出结果:28 match()方法 定义和用法match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 实例12345在字符串中查找 &quot;ain&quot;:var str=&quot;The rain in SPAIN stays mainly in the plain&quot;; var n=str.match(/ain/g);n 输出数组结果值:ain,ain,ain replace()方法 定义和用法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。该方法不会改变原始字符串。 实例12345在本例中，我们将执行一次全局替换，每当 &quot;Microsoft&quot; 被找到，它就被替换为 &quot;Runoob&quot;：var str=&quot;Visit Microsoft!&quot;;var n=str.replace(&quot;Microsoft&quot;,&quot;Runoob&quot;);n 输出结果:Visit Runoob! search()方法 定义和用法search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 实例12345查找 &quot;W3CSchool&quot;:var str=&quot;Visit W3CSchool!&quot;;var n=str.search(&quot;W3CSchool&quot;);n 输出结果：6 search()方法和indexof()一样返回目标自字符串索引值。首先要明确search()的参数必须是正则表达式，而indexOf()的参数只是普通字符串。indexOf()是比search()更加底层的方法。很多时候用indexOf()不是为了真的想知道子字符串的位置，而是想知道长字符串中没有包含这个子字符串。 slice()方法 定义和用法slice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。使用start（包含） 和 end（不包含） 参数来指定字符串提取的部分。字符串中第一个字符位置为 0, 第二个字符位置为 1, 以此类推。提示： 如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 实例12345提取字符串的片断:var str=&quot;Hello world!&quot;;var n=str.slice(1,5);n 输出结果：ello split()方法 定义和用法split() 方法用于把一个字符串分割成字符串数组。提示： 如果把空字符串 (&quot;&quot;) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注意： split()方法不改变原始字符串。 实例123456789把一个字符串分割成字符串数组:var str=&quot;How are you doing today?&quot;;var n=str.split(&quot; &quot;);n 输出一个数组的值:How,are,you,doing,today?a=&quot;a|b|c&quot;;console.log(a.split(&quot;|&quot;));//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]a=&quot;a,b,c&quot;;console.log(a.split(&quot;,&quot;));//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] substr()方法 定义和用法substr() 方法可在字符串中抽取从 开始 下标开始的指定数目的字符。提示： substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice()来使用。注意： substr() 方法不会改变源字符串。 实例12345抽取指定数目的字符：var str=&quot;Hello world!&quot;;var n=str.substr(2,3)n 输出结果:llo substring()方法substring() 方法用于提取字符串中介于两个指定下标之间的字符。substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。substring和slice的区别则是，slice可以接受“负数”，表示从字符串尾部开始计数； 而substring则把负数或其它无效的数，当作0。 实例1234567在本例中，我们将使用 substring() 从字符串中提取一些字符：:var str=&quot;Hello world!&quot;;document.write(str.substring(3)+&quot;&lt;br&gt;&quot;);document.write(str.substring(3,7));以上代码输出结果:lo world!lo w toLowerCase()方法 定义和用法`toLowerCase() 方法用于把字符串转换为小写。 实例123把字符串转换为小写:var str=&quot;Hello World!&quot;;document.write(str.toLowerCase()); toUpperCase()方法 定义和用法`toUpperCase() 方法用于把字符串转换为大写。 实例123把字符串转换为大写:var str=&quot;Hello world!&quot;;document.write(str.toUpperCase()); trim()方法 定义和用法trim() 方法去除字符串两边的空白。 实例1无 valueOf()方法 定义和用法valueOf() 方法可返回 String 对象的原始值。注意： valueOf() 方法通常由 JavaScript 在后台自动进行调用，而不是显式地处于代码中。 实例12345返回 String 对象的原始值:var str=&quot;Hello world!&quot;;document.write(str.valueOf());以上输出结果:Hello world!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础篇（一）——数组的各种操作]]></title>
    <url>%2F2017%2F04%2F14%2Fjs%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js基础篇（三）——DOM的各种操作js基础篇（二）——字符串的各种操作 1. 创建数组创建一个数组，有三种方法。下面的代码定义了一个名为 myCars的数组对象： 1.1 常规方法1234var myCars=new Array(); myCars[0]=&quot;Saab&quot;; myCars[1]=&quot;Volvo&quot;;myCars[2]=&quot;BMW&quot;; 1.2 简洁方法1var myCars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 1.3 字面推荐使用1var myCars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 2.访问数组通过指定数组名以及索引号码，你可以访问某个特定的元素。 2.1 取值以下实例可以访问myCars数组的第一个值：1var name=myCars[0]; 2.2 赋值以下实例修改了数组myCars 的第一个元素:1myCars[0]=&quot;Opel&quot;; 3.数组属性与方法3.1 数组属性 属性 描述 constructor 返回创建数组对象的原型函数。 length 设置或返回数组元素的个数。 prototype 允许你向数组对象添加属性或方法。 3.2 数组方法数组也是对象，数组对象的属性可以称为数组方法，用来操作数组。下列表格是总结，每个方法的示例在下面。 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 indexOf() 搜索数组中的元素，并返回它所在的位置。 join() 把数组的所有元素放入一个字符串。 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 concat() 方法 定义和用法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 实例123456//合并三个数组的值：var hege = [&quot;Cecilie&quot;, &quot;Lone&quot;];var stale = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var kai = [&quot;Robin&quot;];var children = hege.concat(stale,kai);//children 输出结果：Cecilie,Lone,Emil,Tobias,Linus,Robin copyWithin()方法 定义和用法用于从数组的指定位置拷贝元素到数组的另一个指定位置中。 实例12345//复制数组的前面两个元素到后面两个元素上：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.copyWithin(2, 0);//fruits 输出结果：//Banana,Orange,Banana,Orange every()方法 定义和用法every()方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。every() 方法使用指定函数检测数组中的所有元素：如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回true。注意：every()不会对空数组进行检测，不会改变原始数组。 实例 12345678910//检测数组 ages 的所有元素是否都大于 18 :var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = ages.every(checkAdult);&#125;//输出结果为:false fill()方法 定义和用法fill()方法用于将一个固定值替换数组的元素。 实例 12345//使用固定值填充数组：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.fill(&quot;Runoob&quot;);//fruits 输出结果：Runoob,Runoob,Runoob,Runoob filter()方法 定义和用法filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。注意： filter() 不会对空数组进行检测，不会改变原始数组。 实例 12345678910//返回数组 ages 中所有元素都大于 18 的元素:var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = ages.filter(checkAdult);&#125;//输出结果为:32,33,40 find()方法 定义和用法find() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素。find()方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时返回true 时, find()返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1注意: find()对于空数组，函数是不会执行的， 并没有改变数组的原始值。 实例 12345678910//获取数组中年龄大于 18 的第一个元素var ages = [3, 10, 18, 20];function checkAdult(age) &#123; return age &gt;= 16;&#125;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = ages.find(checkAdult);&#125;fruits 输出结果：18 findIndex()方法 定义和用法findIndex()方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。findIndex() 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1注意: findIndex()对于空数组，函数是不会执行的，并没有改变数组的原始值。 实例 12345678910//获取数组中年龄大于 18 的第一个元素索引位置var ages = [3, 10, 18, 20];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = ages.findIndex(checkAdult);&#125;//fruits 输出结果：2 forEach()方法 定义和用法forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。注意: forEach()对于空数组是不会执行回调函数的。 实例 123456789101112131415//列出数组的每个元素：&lt;button onclick=&quot;numbers.forEach(myFunction)&quot;&gt;点我&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;demoP = document.getElementById(&quot;demo&quot;);var numbers = [4, 9, 16, 25];function myFunction(item, index) &#123; demoP.innerHTML = demoP.innerHTML + &quot;index[&quot; + index + &quot;]: &quot; + item + &quot;&lt;br&gt;&quot;;&#125;&lt;/script&gt;//输出结果：index[0]: 4index[1]: 9index[2]: 16index[3]: 25 indexOf()方法 定义和用法indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。 如果在数组中没找到字符串则返回 -1。 提示如果你想查找字符串最后出现的位置，请使用lastIndexOf() 方法。 实例 123456//查找数组中的 &quot;Apple&quot; 元素：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;);//a 结果输出：2以上输出结果意味着 &quot;Apple&quot; 元素位于数组中的第 2 个位置。 join()方法 定义和用法join()方法用于把数组中的所有元素转换一个字符串。元素是通过指定的分隔符进行分隔的。 实例 12345//把数组中的所有元素转换为一个用-连接的字符串：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var energy = fruits.join(&quot;-&quot;);//energy输出结果：Banana-Orange-Apple-Mango lastIndexOf()方法 定义和用法lastIndexOf()方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索，字符位置是从 0 开始的。如果要检索的字符串值没有出现，则该方法返回 -1。提示： 如果你想查找字符串首次出现的位置，请使用indexOf()方法。 实例 12345//查找数组元素 &quot;Apple&quot;出现的位置：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;);//a 输出结果：2 map()方法 定义和用法map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map() 方法按照原始数组元素顺序依次处理元素。注意：map()不会对空数组进行检测，不会改变原始数组。 实例 12345678//返回一个数组，数组中元素为原始数组的平方根:var numbers = [4, 9, 16, 25];function myFunction() &#123; x = document.getElementById(&quot;demo&quot;) x.innerHTML = numbers.map(Math.sqrt);&#125;//输出结果为:2,3,4,5 pop()方法 定义和用法pop()方法用于删除数组的最后一个元素并返回删除的元素。注意：此方法改变数组的长度！提示： 移除数组第一个元素，请使用shift()方法。 实例 12345//移除最后一个数组元素var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop();//fruits 结果输出：Banana,Orange,Apple push()方法 定义和用法push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。注意： 新元素将添加在数组的末尾，此方法改变数组的长度。提示： 在数组起始位置添加元素请使用 unshift()方法。 实例 12345//数组中添加新元素：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;)//fruits 结果输出：Banana,Orange,Apple,Mango,Kiwi reduce()方法 定义和用法reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。注意:reduce() 对于空数组是不会执行回调函数的。 实例1 12345678910//计算数组元素相加后的总和：var numbers = [1, 2, 3, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(&quot;demo&quot;).innerHTML = numbers.reduce(getSum);&#125;//输出结果：10 实例2数组arr = [1,2,3,4]求数组的和 1234//forEach 实现var arr = [1,2,3,4],sum = 0;arr.forEach(function(e)&#123;sum += e;&#125;); // sum = 10 just for demo 1234//map 实现var arr = [1,2,3,4],sum = 0;arr.map(function(obj)&#123;sum += obj&#125;);//return undefined array. sum = 10 just for demo 123//reduce实现var arr = [1,2,3,4];arr.reduce(function(pre,cur)&#123;return pre + cur&#125;); // return 10 reduce() 专为累加这种操作而设计。 reduceRight()方法 定义和用法reduceRight()方法的功能和reduce() 功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。注意: reduce()对于空数组是不会执行回调函数的。 实例 12345678910//计算数组元素相加后的总和：var numbers = [65, 44, 12, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(&quot;demo&quot;).innerHTML = numbers.reduceRight(getSum);&#125;//输出结果：125 reverse()方法 定义和用法reverse()方法用于颠倒数组中元素的顺序。 实例 12345//颠倒数组中元素的顺序：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse();//fruits 结果输出：Mango,Apple,Orange,Banana shift()方法 定义和用法shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。注意： 此方法改变数组的长度！提示： 移除数组末尾的元素可以使用 pop()方法。 实例1234567//从数组中移除元素:var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift()//fruits结果输出:Orange,Apple,Mango//fruits.shift()结果输出：Banana slice()方法 定义和用法slice()方法可从已有的数组中返回选定的元素。slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。注意： slice()方法不会改变原始数组。 实例 12345//在数组中读取元素：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1,3);citrus 结果输出:Orange,Lemon some()方法 定义和用法some()方法用于检测数组中的元素是否满足指定条件（函数提供）。some()方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。注意： some() 不会对空数组进行检测，不会改变原始数组。 实例 12345678910//检测数组中是否有元素大于 18:var ages = [3, 10, 18, 20];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = ages.some(checkAdult);&#125;//输出结果为:true sort()方法 定义和用法sort()方法用于对数组的元素进行排序。默认排序顺序为按字母升序。注意：当数字是按字母顺序排列时”40”将排在”5”前面。使用数字排序，你必须通过一个函数作为参数来调用。函数指定数字是按照升序还是降序排列。注意：这种方法会改变原始数组！ 实例1 12345//数组排序：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort();//fruits 输出结果：Apple,Banana,Mango,Orange 实例2 1234567891011121314151617181920//降序函数 var desc = function(x,y) &#123; if (x &gt; y) return -1; //返回一个小于0 的数即可 else return 1; //返回一个大于0 的数即可 &#125; //升序函数 var asc = function(x,y) &#123; if (x &gt; y) return 1; //返回一个大于0 的数即可 else return -1; //返回一个小于0 的数即可 &#125; var arr2 = [4,6,4,2,7,9,0,1]; arr2.sort(desc); //降序排序 document.writeln(arr2); //9,7,6,4,4,2,1,0document.writeln(&quot;&lt;br&gt;&quot;); arr2.sort(asc); //升序排序 document.writeln(arr2); //0,1,2,4,4,6,7,9 splice()方法 定义和用法splice() 方法用于插入、删除或替换数组的元素。从指定的索引开始删除若干元素，然后再从该位置添加若干元素，注意：这种方法会改变原始数组。 实例12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]原数组arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]原数组arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素原数组arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] toString()方法 定义和用法toString()方法可把数组转换为字符串，并返回结果。注意： 数组中的元素之间用逗号分隔。 实例 12345//将数组转换为字符串：var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.toString();//fruits将输出：Banana,Orange,Apple,Mango unshift()方法 定义和用法unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。注意： 该方法将改变数组的数目。提示: 将新项添加到数组末尾，请使用push() 方法。 实例 1234567//将新项添加到数组起始位置:var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;,&quot;Pineapple&quot;);//fruits 将输出：Lemon,Pineapple,Banana,Orange,Apple,Mango//fruits.unshift 将输出：6 valueOf()方法 定义和用法valueOf() 方法返回Array对象的原始值。该原始值由 Array 对象派生的所有对象继承。valueOf()方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。注意： valueOf() 方法不会改变原数组。 实例1 123456//valueOf() 是数组对象的默认方法。var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var v=fruits.valueOf();// fruits.valueOf()与 fruits返回值一样。//v输出结果为：Banana,Orange,Apple,Mango valueOf()：返回最适合该对象类型的原始值；toString(): 将该对象的原始值以字符串形式返回。这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。在数值运算里，会优先调用valueOf()，如a + b;在字符串运算里，会优先调用toString()，如alert(c);。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中经典问题讲解]]></title>
    <url>%2F2017%2F04%2F14%2Fjs%E4%B8%AD%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.传递参数是按值传递还是按引用传递？苏墨橘的回答JS是按值传递还是按引用传递? 2.执行环境及作用域《javascript高级程序设计》73页至78页 3. 闭包javascript深入理解js闭包深入理解javascript原型和闭包（完结）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简单知识点]]></title>
    <url>%2F2017%2F04%2F14%2Fjs%E7%AE%80%E5%8D%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 条件判断的陷阱在if判断中，使用===作比较,避免掉入==造成的陷阱。 在条件判断时，这样的一些值表示false：null，undefined，字符串&#39; &#39;，数字0，NaN而在==时，则会有一些让人难以理解的陷阱,如：1234567891011(function () &#123; var undefined; undefined == null; // true 1 == true; //true 2 == true; // false 0 == false; // true 0 == &apos;&apos;; // true NaN == NaN;// false [] == false; // true [] == ![]; // true &#125;)(); 对于不同类型的 == 判断，有这样一些规则，顺序自上而下： undefined与null相等 一个是number一个是string时，会尝试将string转换为number 尝试将boolean转换为number，0或1 尝试将Object转换成number或string，取决于另外一个对比量的类型所以，对于0、空字符串的判断，建议使用 === 。===会先判断两边的值类型，类型不匹配时为false。 2. 简单类型转换 number to string的转换，建议使用 1 + &#39; &#39;或String(1)，不使用new String(1)或1.toString()的方式。 string to number的转换，建议使用parseInt，必须显式指定第二个参数的进制。下面的例子展示了不指定进制的风险： 12parseInt(&apos;08&apos;); // 0 parseInt(&apos;08&apos;, 10); //8 float to integer的转换，建议使用Math.floor/Math.round/Math.ceil方法，不使用parseInt。 3. 字符串拼接字符串拼接，应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。如:123456789101112131415不好的拼接方式，+=var str = &apos;&apos;; for (var i = 0, len = list.length; i &lt; len; i++) &#123; str+= &apos;&lt;div&gt;&apos; + list[i] + &apos;&lt;/div&gt;&apos;; &#125; dom.innerHTML = str;正确拼接方式，Array的push+joinvar str = []; for (var i = 0, len = list.length; i &lt; len; i++) &#123; str.push(&apos;&lt;div&gt;&apos;+ list[i] + &apos;&lt;/div&gt;&apos;); &#125; dom.innerHTML = str.join(&apos;&apos;); 4. 获取元素获取单个元素 通常，我们使用document.getElementById来获取dom元素，避免使用document.all。document.getElementById是标准方法，兼容所有浏览器 ie浏览器会混淆元素的id和name属性，document.getElementById可能获得不期望的元素。在对元素的id与name属性的命名需要非常小心，应使用不同的命名法。下面是一个name与id冲突的例子：123&lt;input type=&quot;text&quot; name=&quot;test&quot;&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;button onclick=&quot;alert(document.getElementById(&apos;test&apos;).tagName)&quot;&gt;&lt;/button&gt;&lt;!-- ie6下为INPUT --&gt; 5.设置兼容事件12345678910//设置兼容事件 function addEvent(ele, event, func) &#123; if (ele.addEventListener) &#123; ele.addEventListener(event, func, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent(&apos;on&apos; + event, func); &#125; else &#123; ele[&apos;on&apos; + event] = func; &#125; &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短小精悍的javascript基础知识点]]></title>
    <url>%2F2017%2F04%2F07%2F%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%E7%9A%84javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[注：本文所有知识点总结或摘抄自廖雪峰javascript教程，点击查看更详细的讲解。 1.javascript简介 ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。可以说javascript语言的标准是ECMAScript。 2. 入门基础 在编写JavaScript代码时，经常需要在Console运行测试代码，常用console.log()。 对于复杂的层级嵌套，需要把部分代码抽出来，作为函数调用，以减少代码的复杂程度。 JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。 JavaScript不区分整数和浮点数，统一用Number表示。 JavaScript有两种比较运算符：第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 NaN这个特殊的Number与所有其他值都不相等，包括它自己：1NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数：1isNaN(NaN); // true 面试题中经常出现null undefined NaN相关知识点。 要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 11 / 3 === (1 - 2 / 3); // false null表示一个“空”的值，它和0以及空字符串&#39; &#39;不同，0是一个数值，&#39;&#39;表示长度为0的字符串，而null表示“空”。还有一个和null类似的undefined，它表示“未定义”。 数组的元素可以通过索引来访问，索引的起始值为0。 对象是一组由键（字符串类型）-值（任意数据类型）组成的无序集合，每个键又称为对象的属性。 申明一个变量用var语句，变量名是大小写英文、数字、$和_的组合，不能用数字开头，不能是关键字。 变量本身的数据类型不固定的语言称之为动态语言，与之对应的是静态语言。 变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量。特别需要注意i的声明。 启用strict模式的方法是在JavaScript代码的第一行写上： 1&apos;use strict&apos;; ES6新增了一种模板字符串代替加号： 1234var name = &apos;小明&apos;;var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 常用的操作字符串方法调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串。 toUpperCase()把一个字符串全部变为大写； toLowerCase()把一个字符串全部变为小写； indexOf()会搜索指定字符串出现的位置； 123var s = &apos;hello, world&apos;;s.indexOf(&apos;world&apos;); // 返回7s.indexOf(&apos;World&apos;); // 没有找到指定的子串，返回-1 substring()返回指定索引区间的子串。 123var s = &apos;hello, world&apos;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; 如果通过索引给数组赋值时，索引超过了范围，会引起数据大小的变化： 123var arr = [1, 2, 3];arr[5] = &apos;x&apos;;arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;] 常用的操作数组的方法 indexOf()搜索一个指定的元素的位置； 12var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0 slice()截取Array的部分元素，然后返回一个新的Array： 12var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 不给slice()传递任何参数来复制一个Array。 push()向Array的末尾添加若干元素； pop()则把Array的最后一个元素删除掉； unshift()向Array的头部添加若干元素； shift()则把Array的第一个元素删除掉； sort()会直接修改当前Array的元素位置，对当前Array进行排序； reverse()把整个Array的元素给掉个个，也就是反转； splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array； join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：12var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3];arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; 如果Array的元素不是字符串，将自动转换为字符串后再连接。 JavaScript中能用.的地方就能用[ ]代替： 12xiaohong[&apos;name&apos;]; // &apos;小红&apos;xiaohong.name; // &apos;小红&apos; JavaScript规定，访问不存在的属性不报错，而是返回undefined： 1234var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.age; // undefined 检测xiaoming是否拥有某一属性: 可以用in操作符（无法确定属性来自本身还是来自继承） 12&apos;name&apos; in xiaoming; // true&apos;grade&apos; in xiaoming; // false 可以用hasOwnProperty()方法（判断一个属性是否自身拥有） 12345var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.hasOwnProperty(&apos;name&apos;); // truexiaoming.hasOwnProperty(&apos;toString&apos;); // false if...else...语句的执行特点是二选一，在多个if...else...语句中，如果某个条件成立，则后续就不再继续判断了。 JavaScript把null、undefined、0、NaN和空字符串&#39;&#39;视为false，其他值一概视为true。 for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos;&#125;;for (var key in o) &#123; alert(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];for (var i in a) &#123; alert(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos; alert(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; for ... in对Array的循环得到的是String而不是Number。 Map是一组键（key）值（value）对的结构，具有极快的查找速度。假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 Set和Map类似，也是一组key的集合，但不存储value。 Map和Set是ES6标准新增的数据类型。 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 iterable类型的集合可以通过新的for ... of循环来遍历。for … of循环和for … in循环有何区别？ 函数体内部的语句执行到return时，函数就执行完毕，并将结果返回。如果没有return，返回结果是undefined。 arguments只在函数内部起作用，指向当前函数的调用者传入的所有参数。利用其可以获得调用者传入的所有参数，最常用于判断传入参数的个数。 小心return语句（JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑）：1234function foo() &#123; return &#123; name: &apos;foo&apos; &#125;;&#125;foo(); // &#123; name: &apos;foo&apos; &#125; 12345function foo() &#123; return &#123; name: &apos;foo&apos; &#125;;&#125;foo(); // undefined 定义一个计算圆面积的函数square()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14。一般写法：12345678function square(r, pi) &#123; var r,pi; if(pi) &#123; return pi*r*r; &#125; else &#123; return 3.14*r*r; &#125; 经典写法：123456function square(r, pi) &#123; var r,pi; r = (r || 0) &gt; 0 ? r : 0; pi = pi || 3.14; return pi*r*r; &#125; 用var申明的变量是有作用域的： 变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量； 不同函数内部的同名变量互相独立，互不影响； 嵌套函数时，内部函数可以访问外部函数定义的变量，反过来则不行； 内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。（这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。） 函数会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，但不会提升变量的赋值： 123456function foo() &#123; var x = &apos;Hello, &apos; + y; alert(x); var y = &apos;Bob&apos;;&#125;foo(); //Hello, undefined 不报错：变量y在稍后申明了。 显示Hello, undefined：说明变量y的值为undefined。JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 全局作用域的变量实际上被绑定到window的一个属性。直接访问全局变量a和访问window.a是完全一样的。 用let替代var可以申明一个块级作用域的变量。 ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。 通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：const PI = 3.14;。 绑定到对象上的函数称为方法，和普通函数没啥区别。 在一个方法内部，this是一个特殊变量，它始终指向当前对象。这里有坑：详情移步 廖雪峰-方法 1234567891011function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 即使把xiaoming.age()先给函数，再调用也不行。 12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN ECMA决定，在strict模式下让函数的this指向undefined。 在方法函数内部定义的函数内this指向undefined。 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入 js调用函数时加括号与不加括号的区别：函数名其实就是指向函数体的指针 ， 不加括号， 可以认为是查看该函数的完整信息； 加括号 表示立即调用（执行）这个函数里面的代码（花括号部分的代码）； 不加括号传参，相当于传入函数整体 ； 加括号传参，相当于将函数的返回值作为参数。 Array的map()方法 12345function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce()把结果继续和序列的下一个元素做累积计算： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter()和map()类似也接收一个函数，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20] 闭包，我不敢说太多，因为自己也没有明白得太清楚，但是我感觉这几篇文章值得看。javascript深入理解js闭包深入理解javascript原型和闭包（完结） 箭头函数相当于匿名函数，并且简化了函数定义，两种格式： 简化格式 单参数1x =&gt; x * x 上面的箭头函数相当于：123function (x) &#123; return x * x;&#125; * 多参数 1(x, y) =&gt; x * x + y * y * 无参数 1() =&gt; 3.14 标准格式12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 不要使用·new Number()·、·new Boolean()·、·new String()·创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 Date对象用来表示日期和时间。要获取系统当前时间，用： 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 正则表达式的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 js正则表达式基本语法(精粹) 对象的两个基本概念： 类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生； 实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 window对象不但充当全局作用域，而且表示浏览器窗口。有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作： 更新：更新该DOM节点的内容； innerHTML可以修改一个DOM节点的文本内容，还可以通过HTML片段修改DOM节点内部的子树； innerText或textContent修改一个DOM节点的文本内容，无法设置任何HTML标签。innerText不返回隐藏元素的文本，而textContent返回所有文本。 遍历：遍历该DOM节点下的子节点； 添加：在该DOM节点下新增一个子节点； 如果这个DOM节点是空的，直接使用innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;，不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点； 使用appendChild，把一个子节点添加到父节点的最后一个子节点；*使用insertBefore，把子节点插入到指定的位置。 删除：将该节点从HTML中删除。 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉 感谢各位阅读，欢迎指正错误！！！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多方法解决设置width-100%再设置margin或padding溢出的问题]]></title>
    <url>%2F2017%2F04%2F05%2F%E5%A4%9A%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E8%AE%BE%E7%BD%AEwidth-100-%E5%86%8D%E8%AE%BE%E7%BD%AEmargin%E6%88%96padding%E6%BA%A2%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当设置了父元素的宽度，子元素设置宽度为100%后再在加上子元素上添加padding或margin值就会溢出。举个例子：1234567891011121314151617181920&lt;!-- 示例 --&gt;&lt;!-- html --&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;.parent &#123; width: 500px; height: 50px; background-color: green; border: 1px solid #E74D4D;&#125;.child &#123; width: 100%; height: 30px; margin: 20px; background-color: pink;&#125; 这是因为设置了width: 100%;后已经将父元素占满，再添加margin值就会溢出（默认溢出值为左侧的margin值） 解决方法： 父元素设置padding 12345678910111213&lt;!-- 弊端是增加了parent占用的宽度 --&gt;.parent &#123; width: 500px; height: 50px; padding: 20px; background-color: green; border: 1px solid #E74D4D;&#125;.child &#123; width: 100%; height: 30px; background-color: pink;&#125; [ 推荐 ]利用css3中的box-sizing: border-box; 属性解释链接设置他以后，相当于以怪异模式解析，border和padding全会在你设置的宽度内部。 12345678910111213.parent &#123; width: 500px; height: 50px; padding:20px; background-color: green; border: 1px solid #E74D4D; box-sizing: border-box;&#125;.child &#123; width: 100%; height: 30px; background-color: pink;&#125; 子元素外添加一个div 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child2&quot;&gt; &lt;!-- 设置margin: 20px; --&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; end 下面是彩蛋。。。 我在举这个例子的时候发现了一个css hack（针对不同的浏览器/不同版本写相应的CSS code的过程）：父元素与子元素之间的margin-top问题。html代码123&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; css样式12.box1&#123;height:200px;width:200px;background:gray;&#125; .box2&#123;height:100px;width:100px;background:gold;margin-top:50px;&#125; 结果 父元素的盒子包含一个子元素盒子，给子元素盒子一个垂直外边距margin-top,父元素盒子也会往下走margin-top的值，而子元素和父元素的边距则没有发生变化。 解决方法： 修改父元素的高度，增加padding-top样式模拟（padding-top：1px；常用） 为父元素添加overflow：hidden；样式即可（完美） 为父元素或者子元素声明浮动（float：left；可用） 为父元素添加border（border:1px solid transparent可用） 为父元素或者子元素声明绝对定位 感谢阅读，欢迎指正错误！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[num-=-new-Number(num)-和-num-=-parseInt(num)-的区别]]></title>
    <url>%2F2017%2F04%2F05%2Fnum-new-Number-num-%E5%92%8C-num-parseInt-num-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[javascript 里的数字有两种类型，一种是基本类型数字number,一种是对象类型Number1var str = &quot;123&quot;; 12345parseInt(str) // 得到一个基本类型数据new Number(str) // 得到一个对象类型数据``` 基本类型是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象。当`str`的值，不是数字的时候，处理结果也有所不同。 “123”.length; //6`` 如果str=”123s”，那么parseInt(str) 返回的是 123。new Number(str) 返回的是NaN(javascript内置对象，表示不是一个数字 Not a Number的缩写) 在这个场景下面，如果用户输入数量123s, 比较好的处理是把它转换为123，而不是一个NaN，所以更适合使用parseInt()`。 参考资料：SegmentFault社区关于基本类型数据和对象类型数据的提问中用户hiYoHoo的回答]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转canvas]]></title>
    <url>%2F2017%2F04%2F05%2F%E7%8E%A9%E8%BD%ACcanvas%2F</url>
    <content type="text"><![CDATA[首先需要知道canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成。 1. 基础知识找到 &lt;canvas&gt; 元素:1var c=document.getElementById(&quot;myCanvas&quot;); 然后，创建 context对象：1var context=c.getContext(&quot;2d&quot;); getContext(&quot;2d&quot;) 对象是内建的 HTML5 对象，是一个封装了很多绘图功能的对象。该对象绘制图像的时候有两种方法，分别是context.fill()//填充context.stroke()//绘制边框 在进行图形绘制前，要设置好绘图的样式context.fillStyle//填充的样式context.strokeStyle//边框样式context.lineWidth//图形边框宽度 2. 矩形 属性 描述 rect(x,y,width,height) 创建矩形(一般要配合fill或者stroke使用) fillRect(x,y,width,height) 填充矩形 strokeRect(x,y,width,height) 绘制矩形边框 clearRect(x,y,width,height) 在给定的矩形内清除指定的像素 1234x:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）y:矩形起点纵坐标width:矩形长度height:矩形高度 实例1234//html&lt;canvas id=&quot;myCanvas&quot; width=&quot;340&quot; height=&quot;220&quot; style=&quot;border:1px solid #d3d3d3;padding: 20px;&quot;&gt; 您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt; 1234567891011121314151617//jsvar canvas = document.getElementById(&quot;myCanvas&quot;);var context = canvas.getContext(&quot;2d&quot;);//实践表明在不设施fillStyle下的默认fillStyle=black;context.fillRect(0, 0, 100, 100);//1//实践表明在不设施strokeStyle下的默认strokeStyle=blackcontext.strokeRect(120, 0, 100, 100);//2 //设置纯色context.fillStyle = &quot;red&quot;;context.strokeStyle = &quot;blue&quot;;context.fillRect(0, 120, 100, 100);//3context.strokeRect(120, 120, 100, 100);//4//设置透明度实践证明透明度值&gt;0,&lt;1值越低，越透明，值&gt;=1时为纯色，值&lt;=0时为完全透明context.fillStyle = &quot;rgba(255,0,0,0.2)&quot;;context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;;context.fillRect(240,0 , 100, 100);//5context.strokeRect(240, 120, 100, 100);//6 清除矩形区域 context.clearRect(x,y,width,height)在上述代码中加入 context.clearRect(50, 50, 240, 120);得到如下图形: 3. 圆弧context.arc(x, y, radius, starAngle,endAngle, anticlockwise) 123456x:圆心的x坐标y:圆心的y坐标radius:圆的半径straAngle:开始角度endAngle:结束角度anticlockwise:是否逆时针（true）为逆时针，(false)为顺时针 12345678var canvas = document.getElementById(&quot;mycanvas&quot;);var context = canvas.getContext(&apos;2d&apos;);context.beginPath();context.arc(200, 150, 100, 0, Math.PI * 2, true);//不关闭路径路径会一直保留下去，当然也可以利用这个特点做出意想不到的效果context.closePath();context.fillStyle = &apos;rgba(0,255,0,0.25)&apos;;context.fill(); 4. 路径context.beginPath() context.closePath() 记住每次画路径都在前后加context.beginPath() 和context.closePath()。 5. 绘制线段context.moveTo(x,y) context.lineTo(x,y) 123456789x:x坐标y:y坐标每次画线都从moveTo的点到lineTo的点，如果没有moveTo那么第一次lineTo的效果和moveTo一样，每次lineTo后如果没有moveTo，那么下次lineTo的开始点为前一次lineTo的结束点]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css命名规则大全]]></title>
    <url>%2F2017%2F04%2F04%2Fcss%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[转自css命名规则，有修改。 1.常用CSS样式命名 头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guild服务：service注册：regsiter状态态：status投票：vote合作伙伴：partner 2. id的命名2.1 页面结构 容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center 2.2 导航 导航：nav主导航：mainnav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary 2.3 功能 标志：logo广告：banner登陆：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyright 3. class的命名 (以下做法不推荐）本人不认同原作者的class命名方式，推荐读者参考我之前总结的前端必备编码规范(1)颜色:使用颜色的名称或者16进制代码,如 .red { color: red; }.f60 { color: #f60; }.ff8600 { color: #ff8600; } (2)字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; }.font9pt {font-size: 9pt; } (3)对齐样式,使用对齐目标的英文名称,如 .left { float:left; }.bottom { float:bottom; } (4)标题栏样式,使用”类别+功能”的方式命名,如 .barnews { }.barproduct { } 4. 注意事项 1.一律小写;2.尽量用英文;3.尽量不加中杠和下划线;4.尽量不缩写，除非一看就明白的单词.。 5.css文件命名 主要的 master.css模块 module.css基本共用 base.css布局，版面 layout.css主题 themes.css专栏 columns.css文字 font.css表单 forms.css补丁 mend.css打印 print.css]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div-section和article的区别]]></title>
    <url>%2F2017%2F04%2F04%2Fdiv-section%E5%92%8Carticle%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[div这个标签一直是我们见得最多、用得最多的标签。它本身无任何语义，用作布局以及样式化标签。 section与div相似，但它有更进一步的语义。section用作一段有专题性的内容，一般在它里面会带有标题。 section典型的应用场景应该是文章的章节、标签对话框中的标签页、或者论文中有编号的部分。 1234 &lt;section&gt; &lt;h1&gt;section元素的&lt;/h1&gt;标题 &lt;p&gt;section区块的主题部分&lt;/p&gt; &lt;/section&gt; articlearticle是一个特殊的section标签，它比section具有更明确的语义, 它代表一个独立的、完整的相关内容块。 12345678910&lt;article&gt; &lt;header&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;发表日期：&lt;time pubdate=&quot;pubdate&quot;&gt;2010/10/10&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;article的使用方法&lt;/p&gt; &lt;footer&gt; &lt;p&gt;&lt;small&gt;Copyright @ yiiyaa.net All Rights Reserverd&lt;/samll&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 区别div、section、article，语义是从无到有，逐渐增强的。div无任何语义，仅仅用作样式化或者脚本化的标签，对于一段主题性的内容，则就适用section，而假如这段内容可以脱离上下文，作为完整的独立存在的一段内容，则就适用 article。 原则上来说，能使用article的时候，也是可以使用section的，但是实际上，假如使用article更合适，那么就不要使用section。 关于section元素的使用禁忌 不要将section元素用作设置样式的页面容器，那是div元素的工作； 如果article元素、aside元素或nav元素更符合使用条件，不要使用section元素； 不要为没有标题的内容区块使用section元素。参考资料：div section和article区别HTML5的article和section的区别]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[position-relative和position-absolute]]></title>
    <url>%2F2017%2F03%2F24%2Fposition-relative%E5%92%8Cposition-absolute%2F</url>
    <content type="text"><![CDATA[1.display:block将元素显示为块级元素 总是在新行上开始 高度，行高以及顶和底边距都可控制 宽度缺省是它的容器的100%，除非设定一个宽度 &lt;div&gt; &lt;p&gt; &lt;h1&gt; &lt;form&gt; &lt;ul&gt;和&lt;li&gt;是块元素的例子 2.display:inline将元素显示为行内元素 和其他元素都在一行上 高，行高及顶和底边距不可改变 宽度就是它的文字或图片的宽度，不可改变 &lt;span&gt; &lt;a&gt; &lt;label&gt; &lt;input&gt; &lt;img&gt; &lt;strong&gt; 和&lt;em&gt;是inline元素的例子 3.inline-block将块对象作为内联对象呈递 让块元素和其他元素保持在一行上 高度，行高以及顶和底边距都可控制 4.inline和block的转换情景 让一个inline元素从新行开始 让块元素和其他元素保持在一行上 控制inline元素的宽度（对导航条特别有用） 控制inline元素的高度 无须设定宽度即可为一个块元素设定与文字同宽的背景色 参考资料：display:inline、block、inline-block的区别]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display-inline、block、inline-block的区别]]></title>
    <url>%2F2017%2F03%2F23%2Fdisplay-inline%E3%80%81block%E3%80%81inline-block%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.display:block将元素显示为块级元素 总是在新行上开始 高度，行高以及顶和底边距都可控制 宽度缺省是它的容器的100%，除非设定一个宽度 &lt;div&gt; &lt;p&gt; &lt;h1&gt; &lt;form&gt; &lt;ul&gt;和&lt;li&gt;是块元素的例子 2.display:inline将元素显示为行内元素 和其他元素都在一行上 高，行高及顶和底边距不可改变 宽度就是它的文字或图片的宽度，不可改变 &lt;span&gt; &lt;a&gt; &lt;label&gt; &lt;input&gt; &lt;img&gt; &lt;strong&gt; 和&lt;em&gt;是inline元素的例子 3.inline-block将块对象作为内联对象呈递 让块元素和其他元素保持在一行上 高度，行高以及顶和底边距都可控制 4.inline和block的转换情景 让一个inline元素从新行开始 让块元素和其他元素保持在一行上 控制inline元素的宽度（对导航条特别有用） 控制inline元素的高度 无须设定宽度即可为一个块元素设定与文字同宽的背景色 参考资料：display:inline、block、inline-block的区别]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解overflow]]></title>
    <url>%2F2017%2F03%2F23%2F%E7%90%86%E8%A7%A3overflow%2F</url>
    <content type="text"><![CDATA[我一开始接触到的overflow：hidden是为了防止布局被撑开，一直简单的认为当元素A被定义了overflow：hidden属性时，其内部的子元素B中溢出的内容都将被剪裁（隐藏）。但是其实存在例外的情况。当A拥有overflow：hidden，但是A不具有position:relative或者position:absolute样式，而B恰恰是绝对定位（拥有position:absolute属性），那么B的溢出内容将被显示出来。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>