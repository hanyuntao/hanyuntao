<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javscript面向对象编程--原型和原型链]]></title>
    <url>%2F2017%2F05%2F22%2FJavscript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前言在我的上一篇文章中（面向对象的程序设计–理解对象）讲到了使用原型的好处是可以让对象实例共享它所包含的属性和方法，也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中，那这一篇就详细讲一下原型和原型链。 原型函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。 每创建一个函数的同时会为该函数创建一个prototype属性。这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。 如上图，SuperType是一个函数，右侧的方框就是它的原型。原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。 你也可以在自己自定义的方法的prototype中新增自己的属性12345function Fn() &#123; &#125; Fn.prototype.name = '王福朋'; Fn.prototype.getYear = function () &#123; return 1988; &#125;; 123456789function Fn() &#123; &#125; Fn.prototype.name = '王福朋'; Fn.prototype.getYear = function () &#123; return 1988; &#125;; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性——__proto__，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ === Fn.prototype 隐式原型 每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个__proto__，可成为隐式原型。__proto__用于指向创建它的构造函数的原型对象。 当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。 12var obj = &#123;&#125;;console.log(obj.__proto__=== Object.prototype);//true obj这个对象本质上是被Object函数创建的，因此obj.__proto__=== Object.prototype。我们可以用一个图来表示。 即，每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。那么上图中的Object prototype也是一个对象，它的__proto__指向哪里？在说明Object.prototype之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype。 但是Object.prototype确是一个特例——它的__proto__指向的是null. 还有——函数也是一种对象，函数也有__proto__。 函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 且看如下代码。123function fn (x,y) &#123; return x + y;&#125; 1var fn = new Function("x","y","return x+y"); 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。 首先根本不推荐用第二种方式。 这里只是向大家演示，函数是被Function创建的。 好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype。用一个图来表示。 上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个Function.__proto__指向Function.prototype？这不成了循环引用了？对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以Function是被自身创建的。所以它的__proto__指向了自身的Prototype。 最后一个问题:Function.prototype指向的对象，它的__proto__是不是也指向Object.prototype？ 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则 原型链 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找 javascript中的继承是通过原型链来体现的。 传统原型语法1234567function Foo() &#123;&#125;;Foo.prototype.a = 100;Foo.prototype.b = 200;var f1 = new Foo();f1.a = 10;alert(f1.a); //10alert(f1.b); //200 12345678function Foo() &#123;&#125;var f1 = new Foo();f1.a = 10;Foo.prototype.a = 100;Foo.prototype.b = 200;alert(f1.a); //10alert(f1.b); //200 对象字面量方法添加属性和方法的注意事项 123456789function Foo() &#123;&#125;Foo.prototype = &#123; a: 100, b: 200&#125;var f1 = new Foo();f1.a = 10;alert(f1.a); //10alert(f1.b); //200 12345678910function Foo() &#123;&#125;var f1 = new Foo();f1.a = 10;Foo.prototype = &#123; a: 100, b: 200&#125;alert(f1.a); //10alert(f1.b); //undefined 对象字面量方法添加属性和方法时注意：原型的属性和方法赋值要在新建实例对象之前，不然无法获得原型的值和属性，alert返回相应的undefined 如果在实例上添加新属性，这个属性就会屏蔽原型对象中保存的同名属性，就是阻止访问了属性，而不是修改原型的属性。12345678910111213function Foo() &#123;&#125;;Foo.prototype = &#123; a:100, b:200&#125;var fn1 = new Foo();var fn2 = new Foo();fn1.a = 10;console.log(fn1.a); //10console.log(fn1.b); //200console.log(fn2.a); //100 End本文的大多数观点都来自深入理解javascript原型和闭包，您可以移步该地址查看连续的上下文，以便获得更全面的了解。本文提到了继承，下一篇将会结合高程和阮一峰老师的文章写一下自己对继承的认识。 参考资料深入理解javascript原型和闭包Javascript 面向对象编程（一）：封装《javascript高级程序设计》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javscript面向对象编程--理解对象]]></title>
    <url>%2F2017%2F05%2F22%2FJavscript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。 理解对象一切都是对象——当然，也不是所有的都是对象，值类型就不是对象。123456789101112131415function show(x) &#123; console.log(typeof x); // undefined console.log(typeof 10); // number console.log(typeof 'abc'); // string console.log(typeof true); // boolean console.log(typeof function () &#123;&#125;); //function console.log(typeof [1, 'a', true]); //object console.log(typeof &#123; a: 10, b: 20 &#125;); //object console.log(typeof null); //object console.log(typeof new Number(10)); //object &#125; show(); 以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。(从逻辑角度来看，null值表示一个空的对象指针，这也是typeof操作符检测null值返回object的原因)判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。 对象——若干属性的集合javascript中数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，属性表示为键值对的形式。方法也是属性的一种，只不过方法属性的值是函数。123456789var obj = &#123; a:10, b: function(x) &#123; alert(this.a+x); &#125;, c: &#123; age:15 &#125;&#125; 以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有age属性。这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。1234567891011var fn = function () &#123; alert(100); &#125;; fn.a = 10; fn.b = function () &#123; alert(123); &#125;; fn.c = &#123; name: "yzh", age: 21 &#125;; 上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合。 函数和对象的关系对象都是通过函数创建的12345function Fn() &#123; this.name = 'yzh'; this.year = 1996; &#125; var fn1 = new Fn(); 虽然我们见过字面量创建对象的方法，如:12var obj = &#123; a: 10, b: 20 &#125;;var arr = [5, 'x', true]; 但是这只是快捷方式，其本质是1234567var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = 'x';arr[2] = true; 而其中的 Object 和 Array 都是函数：12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 总结：对象都是通过函数来创建的 封装我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，也就是创建一个对象，我们应该怎么做呢？ 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。1234var Cat = &#123; name : '', color : '' &#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。123456var cat1 = &#123;&#125;; // 创建一个空对象 cat1.name = "大毛"; // 按照原型对象的属性赋值 cat1.color = "黄色";var cat2 = &#123;&#125;; cat2.name = "二毛"; cat2.color = "黑色"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 工厂模式我们可以写一个函数，对原始模式进行改进，解决代码重复的问题。123456function Cat(name,color) &#123; new obj = &#123;&#125;; obj.name = name; obj.color = color; return obj;&#125; 然后生成实例对象，就等于是在调用函数：12var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写，1234function Cat(name,color)&#123; this.name=name; this.color=color; &#125; 我们现在就可以生成实例对象了。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true 要创建Cat的新实例，必须使用new操作符。以这种方法调用构造函数会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象； 执行构造函数中的代码； 返回新对象 Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：123456function Cat(name,color)&#123; this.name = name; this.color = color; this.type = "猫科动物"; this.eat = function()&#123;alert("吃老鼠");&#125;; &#125; 还是采用同样的方法 ，生成实例：1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat ("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。123456function Cat(name,color)&#123; this.name = name; this.color = color; &#125; Cat.prototype.type = "猫科动物"; Cat.prototype.eat = function()&#123;alert("吃老鼠")&#125;; 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(cat1.eat == cat2.eat); //true Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。12alert("name" in cat1); // truealert("type" in cat1); // true 参考资料深入理解javascript原型和闭包 Javascript 面向对象编程（一）：封装 《javascript高级程序设计》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gitpage+hexo快速搭建自己的博客]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%88%A9%E7%94%A8github-hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从下决心自学前端开发开始，每天要看很多资料，之前记录学的东西记录在简书上，慢慢地不满足与使用现成的东西，憧憬在茫茫的互联网中有自己的独立空间。 不是为了给别人看，而是为了 记录自己的成长，记录自己的每一个脚印。 本文是我自己摸索两天，踩过很多坑以后完成的，文章内容综合了很多牛人的技术贴而成，从最最基本的github账号创建到博客各项炫酷功能的完善。由于引用的内容比较杂乱，有多东西都是拼凑而成，侵删。文章主要引用资料都在文章末尾，再次对这些人表示感谢。 Gitpage+hexo想要实现拥有一个独立的私有博客，我们需要两个东西，一个是可供浏览器访问的静态网页存储空间，这个我们选择gitPage，一个是一个静态网页生成工具，Octopress也好，Hexo也罢，这里我选择的是Hexo。 环境准备安装Node到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git安装git，或安装github客户端，感觉github客户端很好用，界面很友好，同样操作起来也比git好用的多！ 安装Hexo使用git shell,依次输入以下代码命令：12cd /npm install hexo-cli -g 命令解释： cd和/之间要有空格，这条指令的作用是返回根目录，也可以在cd /后加入一个文件名，例如下文要用到的cd /Hexo 就可以指向这个文件夹，再输入代码行就默认在在此文件下执行。 githubGitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。 首先注册一个『GitHub』帐号，已有的默认请忽略 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 前两步忽略，只说第三步，添加SSH-Key。首先设置你的用户名密码：12git config --global user.email &quot;bu.ru@qq.com&quot;git config --global user.name &quot;bruce-sha&quot; 生成密钥：1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。 建站本地部署安装Hexo完成后，请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。123456cd /your pathhexo init &lt;folder&gt;cd &lt;folder&gt;npm installhexo generate（可简写为hexo g）hexo sever（可简写为hexo s） 命令解释: 比如我要在D盘test文件夹下建我的博客，博客项目文件夹名称为blog,则执行cd d:/test。 init blog,即在test下面创建blog文件夹。 指向blog目录 安装依赖文件 编译 开启本地服务(第5、6步的操作可以合并成hexo s -g) 此时打开浏览器，在地址栏输入http://localhost:4000/即可查看博客的原型，是不是看到了胜利的曙光；但是如果“显示无法访问此网站”也不要沮丧，我这步是直接看到页面的，你无法访问的原因可能你没有翻墙，因为页面中默认使用了ajax.google.com下的js包。 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 部署博客到服务器也就是把博客部署到github page提供的服务器上。步骤： 首先回到git shell按ctrl+c，之后输入y即可 修改blog文件夹下_config.yml文件，如下图所示修改，repository后的地址要改成你自己的地址：deploy: type: github repo: https://github.com/yourname/blog.git 继续回到git shell输入命令：1234hexo cleanhexo ghexo shexo d 命令解释 - 清除`public`，当 `source` 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。 - 编译，一般部署上去的时候都需要编译一下，编译后，会出现一个 `public` 文件夹，将所有的`md`文件编译成`html`文件 - 部署博客到github上，如果一切顺利，你就通过访问`usename.github.io`访问你的博客了！ 发表博文新建博文继续回到git shell输入：1hexo new “新博文的名字” 即可在 blog\source_posts 目录中找到新博文的名字.md这个文件。你就可以使用maekdown编辑器打开进行编写博客内容了。window编辑器推荐haroopad，支持全平台，免费且强大。 文章模板可能会遇到的问题1hexo new [layout] “postName” #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行 postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 注意，所有文件：后面都必须有个空格，不然会报错。 图片的fancybox效果很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：1234567layout: photo #可省略title: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md1234567layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:---- 然后每次可以执行带layout的new命令生成照片文章：1hexo new photo &quot;photoPostName&quot; #新建照片文章 descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。123456title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述--- hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。 文章摘要在需要显示摘要的地方添加如下代码即可：123以上是摘要&lt;!--more--&gt;以下是余下全文 more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 优雅的在博客上插入图片我试过很多方法，使用以下两种方法最方便 七牛+Mpic使用七牛做图床，使用Mpic随时上传需要用在博客中的图片，支持截图上传，图片复制上传，非常方便。 使用资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于![](/images/image.jpg) 的方法访问它们。 首先确认 _config.yml 中更改 post_asset_folder:true 。 回到git shell，输入1npm install https://github.com/CodeFalling/hexo-asset-image –save 继续执行123hexo cleanhexo ghexo d 重新创建一个博客名字，然后发现blog\source_posts下多了一个与博客名字相同的空文件夹 然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可，是不是特别方便？提醒： 写一篇博文时尽量只使用一种markdown编辑器，如果同时使用两个编辑器，我感觉不同编辑器对markdown语法的编译还是有一些差别的，用这个编辑器写好的格式用另一个编辑器打开却乱了！ 预览和发表使用Travis CI自动部署你的Hexo博客到Github,请参考手把手教你使用Travis CI自动部署你的Hexo博客到Github上 使用could9在线更新博客，这样的话即使更换了电脑，也能优雅的更新博客了。详细请参考：用c9.io实现在线更新博客 安装主题你可以在Themes·Hexo上选择你喜欢的主题，我使用的Next主题 参考Next官方文档,内容十分详尽！安装主题的方法：12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，打开_config.yml，修改主题为next1theme: next 打开hexo\themes\next目录，编辑主题配置文件_config.yml： 技能拓展前言做完以上的内容，你就拥有了一个还不错的博客了，一般用户就够用了。但是我相信你一定不会就此住手的，接下来还会自己折腾的。 授之于鱼不如授之于渔希望我们都能够理解其源码，制作出属于自己专属的个性化博客(•̀ᴗ•́) 其实next主题的最新版（5.1）已经集成了大部分我们需要的插件，只需要在主题配置文件中将默认的false改为true即可，但是我们也仍然需要知道都有哪些新的功能，最有效的方法是直接去查看官网的api：next官网 我们需要改的文件其实也就那么几个，大部分是不需要更改，next都已经帮我们配置好了~默认目录结构： 1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 drafts：草稿文章 posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 我们最先修改的应该是在hexo根目录下的配置文件_config.yml文件，这里是配置整个站点的配置信息，在文章的最后贴出我的配置文件，有兴趣的朋友可以参考一下~其次就是我们的主题配置文件在对应的主题下的_config.yml 因为我使用的是next主题，所以目录的路径为C:\Hexo\themes\next_config.yml 这里配置的是使用主题的配置文件，这个配置文件的东西就有点多了，我们大部分的修改也是在这个文件下完成的。比如说使用集成的第三方插件，默认为false，我们需要将其改为true并且配置相应的app_key就可以使用该插件了~有木有很方便(^ ◕ᴥ◕ ^)然后我们需要修改样式的话是需要设置css和甚至是修改模板，页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以next主题为例：12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 修改Next主题主题颜色打开hexo/themes/next/source/css/_variables/base.styl找到Colors代码段，如下：123456789101112131415161718// Colors// colors for use across theme.// -------------------------------------------------- $whitesmoke = #f5f5f5 $gainsboro = #eee //这个是边栏头像外框的颜色， $gray-lighter = #ddd //文章中插入图片边框颜色 $grey-light = #ccc //文章之间分割线、下划线颜色 $grey = #bbb //页面选中圆点颜色 $grey-dark = #999 $grey-dim = #666 //侧边栏目录字体颜色 $black-light = #555 //修改文章字体颜色 $black-dim = #333 $black-deep = #495a80 //修改主题的颜色，这里我已经改成老蓝色了。 $red = #ff2a2a $blue-bright = #87daff $blue = #0684bd $blue-deep = #262a30 $orange = #F39D01 //浏览文章时，目录选中的颜色 其他的可以自行更改，看看效果，我这里只修改了black-deep和orange的颜色。 主题背景打开hexo/themes/next/source/css/_custom/custom.styl新增如下代码：背景颜色直接更改即可：body { background: #F0F0F0; }添加背景：body { background: url（&#39;/images/background.jpg&#39;); }(将背景图片放到hexo/source/images中即可。 隐藏网页底部powered By Hexo / 强力驱动打开hexo/themes/next/layout/_partials/footer.swig,使用&lt;!— —&gt;隐藏之间的代码即可（隐藏后代码如下），或者直接删除。这时，该行信息即被隐藏，但留有空白，如果你开启了网站流量统计，那么在统计和版权之间会有空行，很不美观，以下方法修改网站流量统计的位置。我这里使用的是不蒜子统计，其他统计类似。打开hexo/themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig将两个&lt;span&gt;标签的class属性改为powered-by和theme-info，对这里使用了刚才删除hexo和主题信息标签的CSS属性，修改后代码如下：1234567891011&#123;% if theme.busuanzicount.enable %&#125; &#123;% if theme.busuanzicount.siteuv %&#125; &#123;&#123; theme.busuanzicount.siteuvheader &#125;&#125;&#123;&#123; theme.busuanzicount.siteuvfooter &#125;&#125; &#123;% endif %&#125; &#123;% if theme.busuanzicount.sitepv %&#125; &#123;&#123; theme.busuanzicount.sitepvheader &#125;&#125;&#123;&#123; theme.busuanzicount.sitepvfooter &#125;&#125; &#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 修改后效果如下： 最后，图上有没有发现我的是一个五角星，默认为心型，在刚才footer.swig文件中找到如下代码：123&lt;span class="with-love"&gt; &lt;i class="fa fa-star"&gt;&lt;/i&gt;&lt;/span&gt; 修改i标签的class属性fa-love，我这里改成了fa-star，其他图形未测过，有兴趣的朋友可以试试。 绑定域名绑定域名的思路如下： 在万网购买自己喜欢的域名（.com的会贵一点，.site和.xyz的相对便宜一些，有的只需要几块钱一年就可以） 解析DNS 在hexo中添加CNAME文件 购买域名之前没有买域名的时候我想使用网易云跟帖，发现在注册网易云跟帖的时候使用原来的域名提示“url已被使用”，这是因为网易云跟帖不认可二级域名，所以要自己买域名。我选择的是万网，阿里下面的。我选择了一个.site的域名，~按照官网的步骤一步一来就可以了~ 解析DNS购买完域名之后我们需要解析DNS地址，在管理控制台中的左侧有域名选项，然后找到你的域名，点击后面的“解析” 点击添加解析，记录类型选A或CNAME， A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。 在hexo中添加CNAME文件 接下来在你的hexo文件夹下source文件夹下新建一个CANME文件,里面加上你刚刚购买的域名比如我的cherryblog.site 然后你就可以hexo clean,hexo g，hexo d 发布你的博客看看效果啦~ 添加菜单页添加菜单页的思路（添加菜单页就是添加一个页面，有两种方式）：第一种是使用git命令hexo new page “photo” 就直接创建了d:\blog\source\photo\index.md文件，然后编辑index.md 文件就可以了~ 在hexo中menu下的内容都是新的页面我们可以通过hexo new page “pagename” 创建，hexo默认的页面只有home,archives,tags 三个，之后我们写的博文就是文章，通过hexo new “name” 创建的name.md 文件在根目录的source_posts 下，在每一个文章的头部，我们可以配置其tags或者categories内容，相当于文章是页面的下一级 ###在配置文件中添加menu索引路径我们可以在主题配置的_config文件下找到相应的字段，字段前加# 表示被注释掉，我们也可以自己添加menu的内容，比如我又新增了两个menulife 和photo这里添加的字段其实是加上文件索引的路径，这里hexo设置的根路径是hexo/source 接下来我们在这个根路径下建立相应的文件夹就可以实现点击mune跳转到相应的页面上了 在source文件添加menu文件夹我们需要在这个路径下自己建立对应的页面，比如说我新建了menulife 和photos，然后再source文件夹下面新建两个名字为life 和photo 的文件夹，里面添加一个index.md markdown文件，内容是类似这样的123456789101112123456title: photodate: 2017-04-04 22:14:07type: &quot;photo&quot;comments: false---啦啦啦~ 给menu添加icon如果只是上面的步骤，那么你可能会创建出一个新的页面，但是显示的效果会是这样： 怎么icon没有换？？？其实hexo中换icon是一个很简单的事情，因为hexo集成了FontAwsome 所以我们只需要在主题的配置文件中加入相应的icon名字即可 查找FontAwsome icon 这时候你想要换一个自己喜欢的icon怎么办，这就需要自己动手，丰衣足食了，你需要自己到FontAwsome官网，然后鼠标往下拉，在图标集中选择自己喜欢的icon，然后记住名字，保存在上面的menu_icon字段中就可以啦~ tips ：在字段中只需要填写icon-name后面跟的name即可，不需要加上前面的”icon-“ 在language添加zh-hans翻译字段上面的步骤完成之后你会发现，在你的博客首页显示的仍然是英文名，而我们想要有一个中文的名字，并且想要个性化定制我们的页面，我们可以在主题的language文件下的zh-hans（中文）语言包下增加相应的字段（做过翻译的童鞋应该都知道什么意思~）还可以修改其他的字段，这样就可以定制我们的博客了呢~ 在发表文章的时候添加对应的menu字段在我们写文章的时候只要在头部信息添加相应的字段就在tags页面和categories中显示相应的分类，例如:12345title: Git使用中的报错情况date: 2017-03-11 23:54:11tags: [git,实战经验] categories: git--- tags、categories都是支持数组的形式的，可以添加多个tags、categories。这样我们在tags、categories页面就可以看见相应的分类了。 添加头像要添加一个这个的头像要怎么操作呢，其实思路就是将你要上传的头像放在你的文件夹中，然后再配置文件中引用正确的路径即可，当然也可以上传绝对路径。在你的主题配置文件找到avatar字段，然后将你得图片路径写在后面，我是新建了一个uploads文件夹，将图片放在下面1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /uploads/avatar.png 设置网站logo跟设置头像其实是一个思路，都是在配置文件中引入正确的地址就可以了，不过网站的logo是对图片有要求的，我们需要在Favicon在线制作工具中制作32*32的.ico图片，然后放在source/images下面。然后在主题配置文件下添加主题配置文件中添加：favicon: images/favicon.ico 自定义样式不得不说next还是很人性化的，你可以个性化定制你的网站，你所有的改动（css）需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，所以只要你不想要你修改的样式，只需要删除这个文件夹就可以了，再也不用担心还原不回去了~ 炫酷动态背景只有两步就可以了添加修改代码next/layout/_layout.swig在&lt;/body&gt;之前加上123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif % 打开next/_config.yml，添加以下代码就可以了：12# Canvas-nestcanvas_nest: true 仿知乎动态背景如果你认为这样效果不够好，只能添加原生的js来仿知乎的登录界面做背景，这就需要修改模板来实现了。首先我们要知道next文件的结构，这样我们想改什么就知道在什么位置了~ 首先在主题文件的layout中的_layout.swigC:\Hexo\themes\next\layout_layout.swig中加入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;div class="bg_content"&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;/div&gt;'use strict'; var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;(); function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); &#125; return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self; &#125; function _inherits(subClass, superClass) &#123; if (typeof superClass !== "function" &amp;&amp; superClass !== null) &#123; throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; &#125; function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125; var Circle = function () &#123; function Circle(x, y) &#123; _classCallCheck(this, Circle); this.x = x; this.y = y; this.r = Math.random() * 10; this._mx = Math.random(); this._my = Math.random(); &#125; _createClass(Circle, [&#123; key: 'drawCircle', value: function drawCircle(ctx) &#123; ctx.beginPath(); //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。 ctx.arc(this.x, this.y, this.r, 0, 360); ctx.closePath(); ctx.fillStyle = 'rgba(204, 204, 204, 0.3)'; ctx.fill(); &#125; &#125;, &#123; key: 'drawLine', value: function drawLine(ctx, _circle) &#123; var dx = this.x - _circle.x; var dy = this.y - _circle.y; var d = Math.sqrt(dx * dx + dy * dy); if (d &lt; 150) &#123; ctx.beginPath(); ctx.moveTo(this.x, this.y); //起始点 ctx.lineTo(_circle.x, _circle.y); //终点 ctx.closePath(); ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)'; ctx.stroke(); &#125; &#125; &#125;, &#123; key: 'move', value: function move(w, h) &#123; this._mx = this.x &lt; w &amp;&amp; this.x &gt; 0 ? this._mx : -this._mx; this._my = this.y &lt; h &amp;&amp; this.y &gt; 0 ? this._my : -this._my; this.x += this._mx / 2; this.y += this._my / 2; &#125; &#125;]); return Circle; &#125;(); var currentCirle = function (_Circle) &#123; _inherits(currentCirle, _Circle); function currentCirle(x, y) &#123; _classCallCheck(this, currentCirle); return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y)); &#125; _createClass(currentCirle, [&#123; key: 'drawCircle', value: function drawCircle(ctx) &#123; ctx.beginPath(); //this.r = (this.r &lt; 14 &amp;&amp; this.r &gt; 1) ? this.r + (Math.random() * 2 - 1) : 2; this.r = 8; ctx.arc(this.x, this.y, this.r, 0, 360); ctx.closePath(); //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')' ctx.fillStyle = 'rgba(255, 77, 54, 0.6)'; ctx.fill(); &#125; &#125;]); return currentCirle; &#125;(Circle); window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d'); var w = canvas.width = canvas.offsetWidth; var h = canvas.height = canvas.offsetHeight; var circles = []; var current_circle = new currentCirle(0, 0); var draw = function draw() &#123; ctx.clearRect(0, 0, w, h); for (var i = 0; i &lt; circles.length; i++) &#123; circles[i].move(w, h); circles[i].drawCircle(ctx); for (j = i + 1; j &lt; circles.length; j++) &#123; circles[i].drawLine(ctx, circles[j]); &#125; &#125; if (current_circle.x) &#123; current_circle.drawCircle(ctx); for (var k = 1; k &lt; circles.length; k++) &#123; current_circle.drawLine(ctx, circles[k]); &#125; &#125; requestAnimationFrame(draw); &#125;; var init = function init(num) &#123; for (var i = 0; i &lt; num; i++) &#123; circles.push(new Circle(Math.random() * w, Math.random() * h)); &#125; draw(); &#125;; window.addEventListener('load', init(60)); window.onmousemove = function (e) &#123; e = e || window.event; current_circle.x = e.clientX; current_circle.y = e.clientY; &#125;; window.onmouseout = function () &#123; current_circle.x = null; current_circle.y = null; 在主题文件的C:\Hexo\themes\next\source\css_custom\custom.styl文件中加上css代码12345678910111213141516/*设置背景*/.bg_content&#123; position: fixed; top: 0; z-index: -1; width: 100%; height: 100%;&#125;#canvas&#123; width: 100%; height:100%;&#125;/*将头部背景变为透明*/.header&#123; background: transparent ;&#125; 添加网易云音乐我们可以直接在网易云音乐中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了layout/_macro/sidebar.swig 文件下 1234&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt;&lt;/div&gt; 然后就可以在侧边栏看见我的播放器了~ 网易云跟帖之前用的是多说，但是多说在2017年6月1日就关闭评论服务了= =，很忧伤，于是转到了网易云跟帖。由于最新版（5.1）版本的next已经集成了网易云跟帖，所以只需要在主题的设置文件中配置你的productKey就可以了。获取productKey也很简单，在官网网易云跟帖中注册，然后在获取代码&gt;通用代码中拿到productKey，之后在你的主题配置文件中的gentie_productKey字段后添加即可~ 添加Fork me on GitHub去网址https://github.com/blog/273-github-ribbons 挑选自己喜欢的样式，并复制代码，添加到themes\next\layout_layout.swig的body标签之内即可记得把里面的url换成自己的! hexo-wordcount实现统计功能wordcount可以实现字数统计，阅读时常还有总字数的统计功能只需要npm install hexo-wordcount –save 就可以安装wordcount插件，主要功能字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount安装完插件之后在主题的配置文件中开启该功能就可以~ 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true leancloud阅读次数统计next也集成了leancloud，在leancloud官网中注册账号等一步一步的操作就不说了哈~，我们主要是为了拿到app_key和app_id,然后在主题配置文件做一下配置123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: yourapp_id app_key: yourapp_key 然后再leancloud的控制台中的存储添加一个counter的class就可以检测到我们的浏览量了，同时在你文章的副标题也可以看到有阅读次数的显示 图床虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。 免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。 七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。 如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。 如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。 您还可以使用如下图床服务 FarBox，Dropbox，又拍云 主题优化Next主题很美观，个人也非常喜欢，但是一点令我们烦恼的就是主题加载的特别缓慢，那怎么优化呢？请参考一下两篇博文，作者已经总结的非常详细了，有需要的可以拜读一下，受益匪浅！ 提升Hexo的NexT主题加载速度 使用gulp精简hexo博客代码 分享我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加： 在hexo\themes\modernist\layout_partial\post下新建jiathis.ejs文件。注册加网获得你的分享代码，写入jiathis.ejs。 在hexo\themes\modernist\layout_partial\article.ejs中，添加&lt;%-partial(‘post/jiathis’)%&gt;。-分享服务还可以使用如下企业提供的技术加网，bShare，百度分享。 自定义挂件除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\themes\modernist\layout_widget\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\themes\modernist_config.yml中配置。12widgets: - myWidget 用上述方法可以添加新浪微博小挂件。 生成自己的微博组件。 添加hexo\themes\modernist\layout_widget\weibo.ejs文件。 配置hexo\themes\modernist_config.yml。 换机器你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。 我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。 参考文献 利用Gitpage+hexo开发自己的博客 修改Hexo的Next主题 hexo你的博客 20分钟教你使用hexo搭建github博客 hexo + github + 多说 来搭建免费博客 利用swiftype为hexo添加站内搜索 博客搬迁记 - 从WordPress到Hexo 在hexo中无痛使用本地图片 手把手教你使用Travis CI自动部署你的Hexo博客到Github上 为Hexo博客生成sitemap 使用gulp精简hexo博客代码 单个GitHub帐号下添加多个GitHub Pages的相关问题 hexo你的博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵活方便的布局方式——弹性布局]]></title>
    <url>%2F2017%2F04%2F18%2F%E7%81%B5%E6%B4%BB%E6%96%B9%E4%BE%BF%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[本篇文章全部摘自阮一峰老师的Flex 布局教程。 之前我一直在用布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。最近在做百度前端技术学院的作业时发现很多人都在用Flex 布局，简单几行代码就能实现特殊的布局，所以我找了点资料，开始学习弹性布局。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。因为一山不容二虎，float、clear和vertical-align属性都是用来布局的属性，一旦使用flex，原来这些古老的属性不失效还留着干什么？ 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。各属性演示地址123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴（垂直轴）上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。1.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。1.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。1.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。1.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow,flex-shrink和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。1.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。1.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 五、Flex布局实例链接5.1 骰子的布局 5.2 网格布局 5.3 圣杯布局 5.4 输入框的布局 5.5 悬挂式布局 5.6 固定的底栏 5.7 流式布局]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>