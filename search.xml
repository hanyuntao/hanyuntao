<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试--CSS篇]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-CSS%E7%AF%87%2F</url>
    <content type="text"><![CDATA[css 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 盒模型有两种， IE 盒子模型、W3C 盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？ 选择器 id选择器（ #myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color; 不可继承的样式：border padding margin width height ; CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag !important 比 内联优先级高 CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 &lt;p&gt;元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled 选择器匹配每个启用的的元素（主要用于表单元素）。 :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 如何居中div？ 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123;width:200px;margin:0 auto;&#125; 让绝对定位的div居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */ &#125; 水平垂直居中 确定容器的宽高 宽500 高 300 的层设置层的外边距 123456789div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; /*前提是html,body &#123;width: 100%;height: 100%;&#125;*/ left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */&#125; 未知容器的宽高，利用 transform 属性 1234567div &#123; position: absolute; /* 相对定位或绝对定位均可 */ top: 50%; /*前提是html,body &#123;width: 100%;height: 100%;&#125;*/ left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */ &#125; 利用 flex 布局,实际使用时应考虑兼容性 12345678910.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display有哪些值？说明他们的作用 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。像行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 像块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。relative 生成相对定位的元素，相对于其正常位置进行定位。static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？ 新增各种CSS选择器 （:not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜例如:transform:scale(0.85,0.90); translate(0px,-30px); skew(-9deg,0deg); 过渡 transition 动画 animation和@keyframes一起使用。 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 具体：灵活方便的布局方式——弹性布局 用纯CSS创建一个三角形的原理是什么？把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567#demo &#123;width: 0;height: 0;border-width: 20px;border-style: solid;border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计?简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 css多列等高如何实现？利用padding-bottom|margin-bottom正负值相抵:父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456.bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 IE下,event对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了？ 被点击访问过的超链接样式不在具有hover和active了，解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {}`` a:hover {} a:active {} 为什么要初始化CSS样式？ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） 淘宝的样式初始化代码：123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; absolute的containing block(容器块)计算方式跟正常流有什么不同？ CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。 position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试--HTML篇]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95--HTML%E7%AF%87%2F</url>
    <content type="text"><![CDATA[html Doctype作用？标准模式与兼容模式(怪异模式)各有什么区别? &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;鲜为人知的是：&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 页面导入样式时，使用link和@import有什么区别？页面中使用CSS的方式主要有3种：行内添加定义style属性值，页面头部内嵌调用和外面链接调用，其中外面引用有两种：link和@import。外部引用CSS两种方式link和@import的方式分别是： 1234 &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;style&gt; @import url(style.css);&lt;/style&gt; 两者都是外部引用CSS的方式，但是存在一定的区别： link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; link支持使用Javascript控制DOM去改变样式；而@import不支持。 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Webkit内核：Safari,Chrome等。 Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]详细文章：浏览器内核的解析和对比 html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML(SGML 是一种很强大但很复杂的标记语言) 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； 浏览器对于HTML5新标签兼容问题： 当在页面中使用HTML5新标签时，可能会得到三种不同的结果： 结果1：新标签被当作错误处理并被忽略，在DOM构建时会当作这个标签不存在。 结果2：新标签被当作错误处理，并在DOM构建时，这个新标签会被构造成行内元素。 结果3：新标签被识别为HTML5标签，然后用DOM节点对其进行替换。 不能识别HTML5新标签而不能使用，解决办法有两种： 方法1：实现标签被识别：通过document.createElement（tagName）方法即可让浏览器识别新标签，浏览器支持新标签后，还可以为新标签添加CSS样式。 方法2：JavaScript解决方案 使用html5shim：在&lt;head&gt;中调用以下代码： 123&lt;!-- [if lt IE 9] --&gt; &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;!-- [endif] --&gt; 使用kill IE6:在&lt;/body&gt;之前调用以下代码： 123&lt;!--if lte IE 6]&gt; &lt;script src="http://letskillie6.googlecode.com/svn/trunk/letskillie6.zh_CN.pack.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明 新增的结构元素\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情; html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源；CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK://offline.html 在离线状态时，操作window.applicationCache进行需求实现。 详细的使用请参考：HTML5 离线缓存-manifest简介有趣的HTML5：离线存储 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？&lt;label&gt;标签为 input 元素定义标注（标记）。label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。&lt;label&gt;标签的 for 属性应当与相关元素的 id 属性相同。 123&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type=“text“name="Name" id="Name"/&gt;&lt;!-- 点击Number会触发id为Name的input --&gt; HTML5的form如何关闭自动完成功能？autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。提示: autocomplete 属性有可能在 form元素中是开启的，而在input元素中是关闭的。给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket（它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端）； SharedWorker（共享工作线程允许多个页面共享使用，每个页面都是链接到该共享工作线程的某个端口号上。页面通过该端口与共享工作线程进行通信）； 也可以调用localstorge、cookies等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放,在线聊天离开状态； 如何在页面上实现一个圆形的可点击区域？ map+area或者svg(SVG 是使用 XML 来描述二维图形和绘图程序的语言。) border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 1&lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>面试</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果你是前端新手，看这篇文章理解闭包就对了]]></title>
    <url>%2F2017%2F05%2F26%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[这几天，看过《javascript高程程序设计》和网上的闭包文章，算是对闭包有一个完整的理解了。一开始本文只想讲一下关于闭包的理解，但是闭包又涉及了很多知识，比如执行环境，作用域，变量对象等。我就想把此文定位为理解闭包的基础文章。我是自学javascript有一段时间了，如若有什么理解错误的地方，请您留言指出，感激不尽。 执行环境和作用域链执行环境也称为上下文环境，是js中非常重要的概念。我们可以将执行环境分为全局执行环境和局部执行环境（函数执行环境），下面我们以一个例子来说明什么是执行环境。123456var a = 1,b=2;function add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125;add(a,b); 对代码的操作可分为：创建–&gt;调用–&gt;执行–&gt;执行结束。当javascript代码被浏览器载入后，默认创建并进入的是全局执行环境。 该执行环境有一个属性，该属性指向一个对象，这个对象就是变量对象。这个对象的属性名是全局环境中所有变量和函数的名，属性的值是变量和函数的值。但是在代码执行前，会初始化这个变量对象。对于本例子而言： 当创建 add 函数的时候， Javascript 引擎会创建 add 函数的 Scope 属性, 这个属性保存了一个由变量对象组成的列表（作用域链）地址，因为目前只有一个全局执行环境的变量对象，所以这个列表中只有一个对象。 。如果用图形形象化的表述如下图所示： 从上图可以看出，当 add 函数创建的时候，作用域链就已经创建了，因此可以得出一个结论，函数的作用域链是创建函数的时候就已经创建了。而作用域链的作用是保证对变量的有序访问，这个时候再想一下js中经常出现的莫名的变量取值就没那么奇怪了：（例子占位）代码从第1行开始一步一步往下执行，全局执行环境的变量对象（此时应该称为活动对象）开始一步一步赋值，在第6行代码执行之前，变量对象变成： 执行到第6行，开始调用函数add(),在开始执行add()函数代码(第2-5行)之前，首先也要为函数创建一个执行环境，初始化add()函数执行环境的变量对象。 然后通过复制[[scope]]属性中的作用域链(变量对象列表),创建add()函数执行环境的作用域链，这个作用域链保存在变量对象中。此后，本函数执行环境的变量对象变成了活动对象，并被推到作用域的顶端。此时add()函数执行环境的变量对象变成： 对于add()而言，其作用域链包含包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。假如我们要在函数中访问一个变量，就会从作用域链中（实际上是变量对象）搜索相应名字的变量。先从本地活动对象中搜，没有的话就再往下搜，直到全局的变量对象。 当执行流(代码执行流程)走到第2行时，函数的执行环境被推入到环境栈里面。一系列活动的执行环境从逻辑上形成一个栈。栈底总是全局环境，栈顶是当前（活动的）执行环境。当在不同的执行环境间切换（退出的而进入新的执行环境）的时候，栈会被修改（通过压栈或者退栈的形式）。 然后代码继续执行，本地活动对象不断完善，执行到第3行时，sum=3。当执行完第4行时，add()函数执行完毕。函数执行环境出栈，执行流进入全局执行环境，函数执行环境被销毁，保存在其中的变量和函数定义（当然，我们的例子中，add()函数执行环境没有函数声明）随之销毁。因为全局执行环境始终存在（全局执行环境直到程序退出-比如说关闭网页或者浏览器-才会销毁），全局变量对象也一直存在。 有一个例外，在这个例外中，即使函数执行完了，执行环境销毁了，但是其变量对象一直存在。不用猜，这个例外是闭包。 闭包 闭包: 名为封闭，实则开放，大包包着小包，小包不仅能够访问包内部的数据，同时也能访问它的外部数据（大包的内部数据），即使大包不调用，小包里只要用到了大包里的数据，数据也是存在的，也能直接拿到。而且只有明确标识返回的是小包里的数据时，才叫闭包。否则就是普通的函数了。 123456789101112var x = 10;function outer() &#123; var y = 20; return function inner() &#123; var sum = x + y; return sum; &#125;&#125;/*outer()的执行结果为一个函数对象，是一个引用类型的值f中保存了指向该对象的指针*/var f = outer();f();//30 第一步，代码执行前生成全局执行环境，并在执行时对其中的变量进行赋值。此时全局执行环境是活动状态。第二步，执行第17行代码时，调用outer()，产生outer()执行上下文环境，压栈，并设置为活动状态。调用outer()， JavaScript 引擎会创建outer()执行上下文的作用域链，这个作用域链包含了outer()执行时的活动对象第三步，执行完第17行，outer()调用完成。按理说应该销毁掉outer()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行outer()()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个变量sum要引用outer()作用域下的outer()()上下文环境中的y。因此，这个y不能被销毁，销毁了之后inner函数中的y就找不到值了。 因此，这里的outer()()上下文环境不能被销毁，还依然存在与执行上下文栈中。 第四步，执行到第18行时，调用inner()，产生inner()执行上下文环境，压栈，并设置为活动状态。，但是outer()上下文环境依然会在执行上下文栈中。如下图： 这里的重点就在于，创建inner函数是在执行outer()时创建的。outer()早就执行结束了，但是outer()执行上下文环境还存在与栈中，因此f()时，y可以查找到。如果outer()上下文环境销毁了，那么y就找不到了。第五步，执行完18行就是上下文环境的销毁过程，这里就不再赘述了。 到此闭包就讲完了，总结一下： 闭包不是私有，闭的意思不是“封闭内部状态”，而是“封闭外部状态”啊。一个函数如何能封闭外部状态呢，当外部状态的scope失效的时候，还有一份留在内部状态里面…… by vczh 参考资料《javascript高级程序设计》第73，178,179页深入理解javascript原型和闭包（15）——闭包原生JS执行环境与作用域深入理解]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用函数整理]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[按照某个属性排序 函数 12345678910111213141516function createComparisonFunction(propertyName) &#123; return function(object1,object2) &#123; var value1 = object1[propertyName] var value2 = object2[propertyName] if(value1 &lt; value2) &#123; return -1; &#125; else if(value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 实例 1234567var data = [&#123;name:"hyt",age:24&#125;,&#123;name:"drx",age:25&#125;];data.sort(createComparisonFunction("name"));console.log(data[0].name); //drxconsole.log(data[1].name); //hytdata.sort(createComparisonFunction("name"));console.log(data[0].name); //hytconsole.log(data[1].name); //drx (占位)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的小知识点]]></title>
    <url>%2F2017%2F05%2F25%2Fjavascript%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言本文主要记录学习过程中发现的且极易被忽略的小知识点，会不断更新内容，经常翻看。另外知识点顺序按照实际遇到的时间记录，无层次无结构。 内容 没有块级作用域1234for(var i=0;i&lt;10;i++) &#123; doSomething(i);&#125;alert(i);//10; 解释：对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境中。而js中，由for语句创建的变量i即使在for语句执行结束以后，也依旧存在于循环外部的执行环境中。 方括号访问对象属性12alert(person.age);//27alert(person["age"]);//27 方块号的优点是: - 可以通过变量来访问属性 12var name = "hyt";alert(person["name"]); - 属性名中可以包含非字母非数字 1person["first name"]; 函数的内部属性arguments、this、caller arguments:是一个类数组 对象 ，包含传入函数中的所有参数。该对象有一个callee属性，该属性是一个指针，指向拥有arguments对象的函数。 this:引用的是函数据以执行的环境对象。 12345678910var color = "red";var o = &#123; color: "blue"&#125;;function sayColor() &#123; console.log(this.color);&#125;o.sayColor = sayColor;sayColor();//redo.sayColor();//blue 牢记：函数的名字只是一个包含指针的变量而已,即使在不同环境中执行,全局sayColor()函数与o.sayColor()指向的仍然是同一个函数。 caller:这个属性保存着调用当前函数的函数引用，如果在全局作用域中调用当前函数，它的值为null。 1234567function a() &#123; b();&#125;function b() &#123; console.log(b.caller);&#125;a(); 结果显示 函数的call和apply方法每个函数都有两个非继承而来的方法：apply()和call()。用途是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。都接受两个参数，第一个参数都是在其中运行的作用域，第二个是参数。apply()参数是数组的形式，call()参数是逐个枚举出来。 123456789101112color = "red";var o = &#123; color: "blue"&#125;;function sayColor() &#123; console.log(this.color);&#125;;sayColor();//redsayColor.call(this);//redsayColor.call(window);//redsayColor.call(o);//blue 函数的bind()方法这个方法会创建一个函数实例，这个函数实例中的this会绑定到传给bind()函数的值。 123456789function sayColor() &#123; //创建一个全局函数 console.log(this.color);&#125; var color = "red"; var o = &#123; color: "blue"&#125;;var sayColor1 = sayColor.bind(o);//创建一个this值绑定了o的sayColor函数的实例sayColor1();//在全局作用域中调用这个函数，结果为blue 活动对象和变量对象的区别变量对象（Variable object）：JS的执行上下文中都有个对象，用来放这个执行上下文中可被访问，但是不能被delete的，函数标示符啊，形参啊，变量声明啊什么的，这些玩意会挂在个对象上。对象的属性对应它们的名字，对象属性的值对应它们的值。但这个对象是规范上或者说是引擎实现上的，不可在JS环境中访问到。活动对象（激活对象）（Activation object）：有了变量对象存每个上下文儿中的东西，但是它啥时候用呢？其实就是每进入一个执行上下文儿，这个执行上下文儿中的变量对象就被激活了，可以用了。也就是该上下文中的，函数标示符啊，形参啊，变量声明啊就可以被访问到了。实话说，俩都是一个东西，都是规范概念上的，只不过是鞋架上的鞋和脚上穿的鞋之间的区别，本质上都是鞋。参考知乎]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript高级程序设计-this]]></title>
    <url>%2F2017%2F05%2F24%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-this%2F</url>
    <content type="text"><![CDATA[this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，123function test()&#123; this.x = 1;&#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则 那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。 纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。 请看下面这段代码，它的运行结果是1。 123456function test()&#123; this.x = 1; alert(this.x);&#125;test(); // 1&#125; 为了证明this就是全局对象，我对代码做一些改变：123456 var x = 1;function test()&#123; alert(this.x);&#125;test(); // 1&#125; 运行结果还是1。再变一下：123456 var x = 1;function test()&#123; this.x = 0;&#125;test();alert(x); //0 作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2; function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为o.m.apply(o); //1运行结果就变成了1，证明了这时this代表的是对象o。 参考资料：阮一峰–Javascript的this用法]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript高级程序设计-执行环境及作用域]]></title>
    <url>%2F2017%2F05%2F24%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[前言理解执行环境和作用域是入门javascript的基础，也是难点，但是高程上对这部分的介绍非常吝啬篇幅，结合高程和一些其他的google出来的资料，形成本篇，以备复习。 代码执行前的准备工作javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。 变量、函数表达式——变量声明，默认赋值为undefined； this——赋值； 函数声明——把函数整个赋值； 这个“代码段”其实分三种情况——全局代码，函数体，eval代码。eval代码不常用，不做总结。 数据的准备情况我们称之为执行上下文或者执行上下文环境。 这也是JavaScript 变量提升的原理。 12345function fn(x) &#123; console.log(arguments); //Arguments &#123; 0: 10, 等 2 项… &#125; console.log(x); //10&#125;fn(10); 以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。 另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。用一个例子说明一下：12345678910var a = 10;function fn() &#123; console.log(a); //a是自由变量 //函数创建时，就确定了a要取值的作用域&#125;function bar() &#123; var a = 20; fn(); //打印10不是20&#125;bar(fn); //10 给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。 执行上下文栈执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。执行上下文栈就是是一个压栈出栈的过程。 12345678910111213var a = 10, //1.进入全局上下文环境fn,bar = function(x) &#123; var b = 5; fn(x + b); //3.进入fn函数上下文环境&#125;;fn = function(y) &#123; var c = 5; console.log(y + c);&#125;bar(10); //2.进入bar函数上下文环境 在执行代码之前，首先将创建全局上下文环境。 然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。 执行到第13行，调用bar函数。 跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。 并将这个执行上下文环境压栈，设置为活动状态。 执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。 待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。 好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。 作用域提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：javascript没有块级作用域”。所谓块，就是大括号“｛｝”中间的语句。例如if语句：12345var i = 10;if (i &gt; 1) &#123; var name = "hyt";&#125;console.log(name); //hyt for语句1234for (var i = 0; i &lt; 10; i++) &#123;&#125;console.log(i); //10 我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义 1234var i;for (i = 0; i &lt; 10; i++) &#123;&#125;console.log(i); 你光知道javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。 我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式 2017-04-18-灵活方便的布局方式——弹性布局.md 如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突 例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。 如上图，我们在上文中已经介绍了，除了全局作用域之外 每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。 下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。 第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。 第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。 第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。 第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。 第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。 最后我们可以把以上这几个图片连接起来看看。 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 自由变量在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。123456var x = 50;function fn() &#123; var b = 20; console.log(x + b);&#125;fn(); //70 在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？ 有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：1234567891011var x = 50;function fn() &#123; console.log(x);&#125;function show(f) &#123; var x = 20; (function() &#123; f(); //50 不是20 &#125;)();&#125;show(fn); //50 不是20 不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。 对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。 上面描述的只是跨一步作用域去寻找。 如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。 这个一步一步“跨”的路线，我们称之为——作用域链。123456789101112131415var color = "blue";function changeColor() &#123; var anotherColor = "red"; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color,anotherColor和tempColor &#125; //这里可以访问color和anotherColor,但不能访问tempColor swapColors();&#125;changeColor(); //注释后alert显示为blue //这里只能访问coloralert("Color is now " + color); //red 以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。 全局环境 changeColor()的局部环境 swapColors()的局部环境 变量color 变量anotherColor 变量tempColor 函数changeColor() 函数swapColors() 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 参考资料深入理解javascript原型和闭包——执行上下文栈深入理解javascript原型和闭包-作用域和上下文环境]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
        <tag>高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript高级程序设计--基本类型和引用类型的值]]></title>
    <url>%2F2017%2F05%2F24%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言JS中变量是松散型变量，变量的值及其数据类型可用在脚本的生命周期内改变。本文为自己的学习笔记，来自高程的第四章内容。 基本类型和引用类型js变量的值分两种：基本类型值和引用类型值。Undefined、Null、Boolean、Number、String这五种基本类型是安值访问。引用类型的值保存在内存中，不直接被访问，当复制保存对象变量时，操作对象的引用。为对象添加属性时操作的则是对象。123var a =123;a.age = 27;alert(a.age);//undefined 上述代码说明，基本类型可以像对象类型一样使用，包括访问其属性、对其属性赋值(尽管实际上不起作用，但是形式上可以)。 之所以能这样去使用基本类型，是因为JavaScript引擎内部在处理对某个基本类型a进行形如a.age的操作时，会在内部临时创建一个对应的包装类型(对数字类型来说就是Number类型)的临时对象(new Number())，并把对基本类型的操作代理到对这个临时对象身上，使得对基本类型的属性访问看起来像对象一样。但是在操作完成后，临时对象就扔掉了，下次再访问时，会重新建立临时对象，当然对之前的临时对象的修改都不会有效了。 复制变量值基本类型值复制时会，会在变量对象创建一个新值，并把值复制到新的位置上。两个变量现在是相互独立的。引用类型值复制的实际同样也是在变量对象创建一个新值，并把值复制到新的位置上。不同的是这个值是一个假身（指向对象位置的指针） 这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了。 函数传参高程中关于函数传递参数一上来就各种强调开发人员会错误的认为参数是按引用传递，其实传参是按值传递的。刚开始不理解，后来各种查，终于明白了。 重点理解:按照引用传递会把整个对象传递给形参，按照值传递是把对象的引用值复制给形参12345678function setName(obj) &#123;//将person的引用值复制给obj obj.name="Nicholas";//也即person.name="Nicholas" obj=new Object( );//生成一个新的对象，并且将该对象的引用值复制给obj obj.name="Greg";//根据值复制的特性，现在obj和person是完全独立的，指向不同的对象&#125;var person=new Object( );setName(person);console.log(person.name);//Nicholas var obj = new Object();会重新给obj分配一个地址，比如是0x321了，这个地址指向新生成的局部对象，而这个局部对象会在函数执行完毕后销毁。 检测类型检测基本数据类型typeof操作符是最佳的工具 用来判断string、number、boolean、undefined、function 123456console.log(typeof("a"));//stringconsole.log(typeof(22));//numberconsole.log(typeof(true));//booleanconsole.log(typeof(a));//undefinedconsole.log(typeof(null));//objectconsole.log(typeof(function()&#123;&#125;));//function 可以看出typeof无法检测null,但是可以检测function。 检测引用类型数据instanceof操作符是最佳的工具 排除基本类型值 1console.log(123 instanceof Object);//flase 判读对象和数组 12console.log(person instanceof Object);console.log(color instanceof Array);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
        <tag>高程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javscript面向对象编程-继承]]></title>
    <url>%2F2017%2F05%2F23%2FJavscript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[构造函数、实例和原型对象的关系ECMAscript中描述了原型的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 构造函数、原型、实例的关系：实例就是通过构造函数创建的。实例一创造出来就具有__proto__属性（指向原型对象）。 构造函数中有一个prototype属性，这个属性是一个指针，指向它的原型对象。 原型对象内部也有一个指针（constructor属性）指向构造函数:Person.prototype.constructor = Person; 实例可以访问原型对象上定义的属性和方法。 在这里person1和person2就是实例，prototype是他们的原型对象。12345678910111213141516171819&lt;script&gt; function Animal(name) //积累构造函数 &#123; this.name = name;//设置对象属性 &#125; Animal.prototype.behavior = function() //给基类构造函数的prototype添加behavior方法 &#123; alert("this is a "+this.name); &#125; var Dog = new Animal("dog");//创建Dog对象 var Cat = new Animal("cat");//创建Cat对象 Dog.behavior();//通过Dog对象直接调用behavior方法 Cat.behavior();//output "this is a cat" alert(Dog.behavior==Cat.behavior);//output true;&lt;/script&gt; 可以从程序运行结果看出，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。（可以试一下将Animal.prototype.behavior 中的prototype属性去掉，看看还能不能运行。）在这里，constructor属性指向Animal对象。 构造函数的继承比如，现在有一个”动物”对象的构造函数。123function Animal()&#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 怎样才能使”猫”继承”动物”呢？ 构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 prototype模式第二种方法更常见，使用prototype属性。如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？1Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有Cat.prototype = new Animal();这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行Cat.prototype = new Animal();这一行之后，cat1.constructor也指向Animal！1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写：12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，将Cat的prototype对象指向Animal的prototype对象，这样就完成了继承。1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。所以，上面这一段代码其实是有问题的。请看第二行1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！1alert(Animal.prototype.constructor); // Cat 利用空对象作为中介由于”直接继承prototype存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。1alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 使用的时候，方法如下123extend(Cat,Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 另外，说明一点，函数体最后一行Child.uber = Parent.prototype;意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 拷贝继承上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123;&#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。使用的时候，这样写：123extend2(Cat, Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 非构造函数的继承什么是”非构造函数”的继承？比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。 object()方法json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。12345function object(o) &#123;//引入对象o function F() &#123;&#125; F.prototype = o; return new F();//返回一个prototype指向o的对象&#125; 使用的时候，第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 浅拷贝除了使用prototype链以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。下面这个函数，就是在做拷贝：12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i];//把传入的对象p的属性都复制给c &#125; c.uber = p; return c;&#125; 使用的时候，这样写：123var Doctor = extendCopy(Chinese);Doctor.career = '医生';alert(Doctor.nation); // 中国 但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。 1Chinese.birthPlaces = ['北京','上海','香港']; 通过extendCopy()函数，Doctor继承了Chinese。1var Doctor = extendCopy(Chinese); 然后，我们为Doctor的”出生地”添加一个城市：1Doctor.birthPlaces.push('厦门'); 发生了什么事？Chinese的”出生地”也被改掉了！12alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门 所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。 深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。12345678910111213function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：12Chinese.birthPlaces = ['北京','上海','香港'];Doctor.birthPlaces.push('厦门'); 这时，父对象就不会受到影响了。12alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 目前，jQuery库使用的就是这种继承方法。 结束本文所有知识点及代码来之阮一峰老师的文章《Javascript面向对象编程（二）：构造函数的继承》和《Javascript面向对象编程（三）：非构造函数的继承》 参考资料Javascript面向对象编程（二）：构造函数的继承Javascript面向对象编程（三）：非构造函数的继承]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javscript面向对象编程--原型和原型链]]></title>
    <url>%2F2017%2F05%2F22%2FJavscript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前言在我的上一篇文章中（面向对象的程序设计–理解对象）讲到了使用原型的好处是可以让对象实例共享它所包含的属性和方法，也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中，那这一篇就详细讲一下原型和原型链。 原型函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。 每创建一个函数的同时会为该函数创建一个prototype属性。这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。 如上图，SuperType是一个函数，右侧的方框就是它的原型。原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。 你也可以在自己自定义的方法的prototype中新增自己的属性12345function Fn() &#123; &#125; Fn.prototype.name = '王福朋'; Fn.prototype.getYear = function () &#123; return 1988; &#125;; 123456789function Fn() &#123; &#125; Fn.prototype.name = '王福朋'; Fn.prototype.getYear = function () &#123; return 1988; &#125;; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。 因为每个对象都有一个隐藏的属性——__proto__，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ === Fn.prototype 隐式原型 每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个__proto__，可成为隐式原型。__proto__用于指向创建它的构造函数的原型对象。 当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。 12var obj = &#123;&#125;;console.log(obj.__proto__=== Object.prototype);//true obj这个对象本质上是被Object函数创建的，因此obj.__proto__=== Object.prototype。我们可以用一个图来表示。 即，每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。那么上图中的Object prototype也是一个对象，它的__proto__指向哪里？在说明Object.prototype之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.prototype。 但是Object.prototype确是一个特例——它的__proto__指向的是null. 还有——函数也是一种对象，函数也有__proto__。 函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。 且看如下代码。123function fn (x,y) &#123; return x + y;&#125; 1var fn = new Function("x","y","return x+y"); 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。 首先根本不推荐用第二种方式。 这里只是向大家演示，函数是被Function创建的。 好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype。用一个图来表示。 上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个Function.__proto__指向Function.prototype？这不成了循环引用了？对！是一个环形结构。 其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以Function是被自身创建的。所以它的__proto__指向了自身的Prototype。 最后一个问题:Function.prototype指向的对象，它的__proto__是不是也指向Object.prototype？ 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则 原型链 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找 javascript中的继承是通过原型链来体现的。 传统原型语法1234567function Foo() &#123;&#125;;Foo.prototype.a = 100;Foo.prototype.b = 200;var f1 = new Foo();f1.a = 10;alert(f1.a); //10alert(f1.b); //200 12345678function Foo() &#123;&#125;var f1 = new Foo();f1.a = 10;Foo.prototype.a = 100;Foo.prototype.b = 200;alert(f1.a); //10alert(f1.b); //200 对象字面量方法添加属性和方法的注意事项 123456789function Foo() &#123;&#125;Foo.prototype = &#123; a: 100, b: 200&#125;var f1 = new Foo();f1.a = 10;alert(f1.a); //10alert(f1.b); //200 12345678910function Foo() &#123;&#125;var f1 = new Foo();f1.a = 10;Foo.prototype = &#123; a: 100, b: 200&#125;alert(f1.a); //10alert(f1.b); //undefined 对象字面量方法添加属性和方法时注意：原型的属性和方法赋值要在新建实例对象之前，不然无法获得原型的值和属性，alert返回相应的undefined 如果在实例上添加新属性，这个属性就会屏蔽原型对象中保存的同名属性，就是阻止访问了属性，而不是修改原型的属性。12345678910111213function Foo() &#123;&#125;;Foo.prototype = &#123; a:100, b:200&#125;var fn1 = new Foo();var fn2 = new Foo();fn1.a = 10;console.log(fn1.a); //10console.log(fn1.b); //200console.log(fn2.a); //100 End本文的大多数观点都来自深入理解javascript原型和闭包，您可以移步该地址查看连续的上下文，以便获得更全面的了解。本文提到了继承，下一篇将会结合高程和阮一峰老师的文章写一下自己对继承的认识。 参考资料深入理解javascript原型和闭包Javascript 面向对象编程（一）：封装《javascript高级程序设计》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javscript面向对象编程--理解对象]]></title>
    <url>%2F2017%2F05%2F22%2FJavscript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。 理解对象一切都是对象——当然，也不是所有的都是对象，值类型就不是对象。123456789101112131415function show(x) &#123; console.log(typeof x); // undefined console.log(typeof 10); // number console.log(typeof 'abc'); // string console.log(typeof true); // boolean console.log(typeof function () &#123;&#125;); //function console.log(typeof [1, 'a', true]); //object console.log(typeof &#123; a: 10, b: 20 &#125;); //object console.log(typeof null); //object console.log(typeof new Number(10)); //object &#125; show(); 以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。(从逻辑角度来看，null值表示一个空的对象指针，这也是typeof操作符检测null值返回object的原因)判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。 对象——若干属性的集合javascript中数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，属性表示为键值对的形式。方法也是属性的一种，只不过方法属性的值是函数。123456789var obj = &#123; a:10, b: function(x) &#123; alert(this.a+x); &#125;, c: &#123; age:15 &#125;&#125; 以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有age属性。这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。1234567891011var fn = function () &#123; alert(100); &#125;; fn.a = 10; fn.b = function () &#123; alert(123); &#125;; fn.c = &#123; name: "yzh", age: 21 &#125;; 上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合。 函数和对象的关系对象都是通过函数创建的12345function Fn() &#123; this.name = 'yzh'; this.year = 1996; &#125; var fn1 = new Fn(); 虽然我们见过字面量创建对象的方法，如:12var obj = &#123; a: 10, b: 20 &#125;;var arr = [5, 'x', true]; 但是这只是快捷方式，其本质是1234567var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = 'x';arr[2] = true; 而其中的 Object 和 Array 都是函数：12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 总结：对象都是通过函数来创建的 封装我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，也就是创建一个对象，我们应该怎么做呢？ 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。1234var Cat = &#123; name : '', color : '' &#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。123456var cat1 = &#123;&#125;; // 创建一个空对象 cat1.name = "大毛"; // 按照原型对象的属性赋值 cat1.color = "黄色";var cat2 = &#123;&#125;; cat2.name = "二毛"; cat2.color = "黑色"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 工厂模式我们可以写一个函数，对原始模式进行改进，解决代码重复的问题。123456function Cat(name,color) &#123; new obj = &#123;&#125;; obj.name = name; obj.color = color; return obj;&#125; 然后生成实例对象，就等于是在调用函数：12var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写，1234function Cat(name,color)&#123; this.name=name; this.color=color; &#125; 我们现在就可以生成实例对象了。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true 要创建Cat的新实例，必须使用new操作符。以这种方法调用构造函数会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象； 执行构造函数中的代码； 返回新对象 Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：123456function Cat(name,color)&#123; this.name = name; this.color = color; this.type = "猫科动物"; this.eat = function()&#123;alert("吃老鼠");&#125;; &#125; 还是采用同样的方法 ，生成实例：1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat ("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。123456function Cat(name,color)&#123; this.name = name; this.color = color; &#125; Cat.prototype.type = "猫科动物"; Cat.prototype.eat = function()&#123;alert("吃老鼠")&#125;; 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(cat1.eat == cat2.eat); //true Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。12alert("name" in cat1); // truealert("type" in cat1); // true 参考资料深入理解javascript原型和闭包 Javascript 面向对象编程（一）：封装 《javascript高级程序设计》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gitpage+hexo快速搭建自己的博客]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%88%A9%E7%94%A8github-hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从下决心自学前端开发开始，每天要看很多资料，之前记录学的东西记录在简书上，慢慢地不满足与使用现成的东西，憧憬在茫茫的互联网中有自己的独立空间。 不是为了给别人看，而是为了 记录自己的成长，记录自己的每一个脚印。 本文是我自己摸索两天，踩过很多坑以后完成的，文章内容综合了很多牛人的技术贴而成，从最最基本的github账号创建到博客各项炫酷功能的完善。由于引用的内容比较杂乱，有多东西都是拼凑而成，侵删。文章主要引用资料都在文章末尾，再次对这些人表示感谢。 Gitpage+hexo想要实现拥有一个独立的私有博客，我们需要两个东西，一个是可供浏览器访问的静态网页存储空间，这个我们选择gitPage，一个是一个静态网页生成工具，Octopress也好，Hexo也罢，这里我选择的是Hexo。 环境准备安装Node到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git安装git，或安装github客户端，感觉github客户端很好用，界面很友好，同样操作起来也比git好用的多！ 安装Hexo使用git shell,依次输入以下代码命令：12cd /npm install hexo-cli -g 命令解释： cd和/之间要有空格，这条指令的作用是返回根目录，也可以在cd /后加入一个文件名，例如下文要用到的cd /Hexo 就可以指向这个文件夹，再输入代码行就默认在在此文件下执行。 githubGitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。 首先注册一个『GitHub』帐号，已有的默认请忽略 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 前两步忽略，只说第三步，添加SSH-Key。首先设置你的用户名密码：12git config --global user.email &quot;bu.ru@qq.com&quot;git config --global user.name &quot;bruce-sha&quot; 生成密钥：1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh： 将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。 建站本地部署安装Hexo完成后，请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。123456cd /your pathhexo init &lt;folder&gt;cd &lt;folder&gt;npm installhexo generate（可简写为hexo g）hexo sever（可简写为hexo s） 命令解释: 比如我要在D盘test文件夹下建我的博客，博客项目文件夹名称为blog,则执行cd d:/test。 init blog,即在test下面创建blog文件夹。 指向blog目录 安装依赖文件 编译 开启本地服务(第5、6步的操作可以合并成hexo s -g) 此时打开浏览器，在地址栏输入http://localhost:4000/即可查看博客的原型，是不是看到了胜利的曙光；但是如果“显示无法访问此网站”也不要沮丧，我这步是直接看到页面的，你无法访问的原因可能你没有翻墙，因为页面中默认使用了ajax.google.com下的js包。 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 部署博客到服务器也就是把博客部署到github page提供的服务器上。步骤： 首先回到git shell按ctrl+c，之后输入y即可 修改blog文件夹下_config.yml文件，如下图所示修改，repository后的地址要改成你自己的地址：deploy: type: github repo: https://github.com/yourname/blog.git 继续回到git shell输入命令：1234hexo cleanhexo ghexo shexo d 命令解释 - 清除`public`，当 `source` 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。 - 编译，一般部署上去的时候都需要编译一下，编译后，会出现一个 `public` 文件夹，将所有的`md`文件编译成`html`文件 - 部署博客到github上，如果一切顺利，你就通过访问`usename.github.io`访问你的博客了！ 发表博文新建博文继续回到git shell输入：1hexo new “新博文的名字” 即可在 blog\source_posts 目录中找到新博文的名字.md这个文件。你就可以使用maekdown编辑器打开进行编写博客内容了。window编辑器推荐haroopad，支持全平台，免费且强大。 文章模板可能会遇到的问题1hexo new [layout] “postName” #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行 postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 注意，所有文件：后面都必须有个空格，不然会报错。 图片的fancybox效果很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：1234567layout: photo #可省略title: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md1234567layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:---- 然后每次可以执行带layout的new命令生成照片文章：1hexo new photo &quot;photoPostName&quot; #新建照片文章 descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。123456title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述--- hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。 文章摘要在需要显示摘要的地方添加如下代码即可：123以上是摘要&lt;!--more--&gt;以下是余下全文 more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 优雅的在博客上插入图片我试过很多方法，使用以下两种方法最方便 七牛+Mpic使用七牛做图床，使用Mpic随时上传需要用在博客中的图片，支持截图上传，图片复制上传，非常方便。 使用资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于![](/images/image.jpg) 的方法访问它们。 首先确认 _config.yml 中更改 post_asset_folder:true 。 回到git shell，输入1npm install https://github.com/CodeFalling/hexo-asset-image –save 继续执行123hexo cleanhexo ghexo d 重新创建一个博客名字，然后发现blog\source_posts下多了一个与博客名字相同的空文件夹 然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可，是不是特别方便？提醒： 写一篇博文时尽量只使用一种markdown编辑器，如果同时使用两个编辑器，我感觉不同编辑器对markdown语法的编译还是有一些差别的，用这个编辑器写好的格式用另一个编辑器打开却乱了！ 预览和发表使用Travis CI自动部署你的Hexo博客到Github,请参考手把手教你使用Travis CI自动部署你的Hexo博客到Github上 使用could9在线更新博客，这样的话即使更换了电脑，也能优雅的更新博客了。详细请参考：用c9.io实现在线更新博客 安装主题你可以在Themes·Hexo上选择你喜欢的主题，我使用的Next主题 参考Next官方文档,内容十分详尽！安装主题的方法：12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，打开_config.yml，修改主题为next1theme: next 打开hexo\themes\next目录，编辑主题配置文件_config.yml： 技能拓展前言做完以上的内容，你就拥有了一个还不错的博客了，一般用户就够用了。但是我相信你一定不会就此住手的，接下来还会自己折腾的。 授之于鱼不如授之于渔希望我们都能够理解其源码，制作出属于自己专属的个性化博客(•̀ᴗ•́) 其实next主题的最新版（5.1）已经集成了大部分我们需要的插件，只需要在主题配置文件中将默认的false改为true即可，但是我们也仍然需要知道都有哪些新的功能，最有效的方法是直接去查看官网的api：next官网 我们需要改的文件其实也就那么几个，大部分是不需要更改，next都已经帮我们配置好了~默认目录结构： 1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 drafts：草稿文章 posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 我们最先修改的应该是在hexo根目录下的配置文件_config.yml文件，这里是配置整个站点的配置信息，在文章的最后贴出我的配置文件，有兴趣的朋友可以参考一下~其次就是我们的主题配置文件在对应的主题下的_config.yml 因为我使用的是next主题，所以目录的路径为C:\Hexo\themes\next_config.yml 这里配置的是使用主题的配置文件，这个配置文件的东西就有点多了，我们大部分的修改也是在这个文件下完成的。比如说使用集成的第三方插件，默认为false，我们需要将其改为true并且配置相应的app_key就可以使用该插件了~有木有很方便(^ ◕ᴥ◕ ^)然后我们需要修改样式的话是需要设置css和甚至是修改模板，页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以next主题为例：12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 修改Next主题主题颜色打开hexo/themes/next/source/css/_variables/base.styl找到Colors代码段，如下：123456789101112131415161718// Colors// colors for use across theme.// -------------------------------------------------- $whitesmoke = #f5f5f5 $gainsboro = #eee //这个是边栏头像外框的颜色， $gray-lighter = #ddd //文章中插入图片边框颜色 $grey-light = #ccc //文章之间分割线、下划线颜色 $grey = #bbb //页面选中圆点颜色 $grey-dark = #999 $grey-dim = #666 //侧边栏目录字体颜色 $black-light = #555 //修改文章字体颜色 $black-dim = #333 $black-deep = #495a80 //修改主题的颜色，这里我已经改成老蓝色了。 $red = #ff2a2a $blue-bright = #87daff $blue = #0684bd $blue-deep = #262a30 $orange = #F39D01 //浏览文章时，目录选中的颜色 其他的可以自行更改，看看效果，我这里只修改了black-deep和orange的颜色。 主题背景打开hexo/themes/next/source/css/_custom/custom.styl新增如下代码：背景颜色直接更改即可：body { background: #F0F0F0; }添加背景：body { background: url（&#39;/images/background.jpg&#39;); }(将背景图片放到hexo/source/images中即可。 隐藏网页底部powered By Hexo / 强力驱动打开hexo/themes/next/layout/_partials/footer.swig,使用&lt;!— —&gt;隐藏之间的代码即可（隐藏后代码如下），或者直接删除。这时，该行信息即被隐藏，但留有空白，如果你开启了网站流量统计，那么在统计和版权之间会有空行，很不美观，以下方法修改网站流量统计的位置。我这里使用的是不蒜子统计，其他统计类似。打开hexo/themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig将两个&lt;span&gt;标签的class属性改为powered-by和theme-info，对这里使用了刚才删除hexo和主题信息标签的CSS属性，修改后代码如下：1234567891011&#123;% if theme.busuanzicount.enable %&#125; &#123;% if theme.busuanzicount.siteuv %&#125; &#123;&#123; theme.busuanzicount.siteuvheader &#125;&#125;&#123;&#123; theme.busuanzicount.siteuvfooter &#125;&#125; &#123;% endif %&#125; &#123;% if theme.busuanzicount.sitepv %&#125; &#123;&#123; theme.busuanzicount.sitepvheader &#125;&#125;&#123;&#123; theme.busuanzicount.sitepvfooter &#125;&#125; &#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 修改后效果如下： 最后，图上有没有发现我的是一个五角星，默认为心型，在刚才footer.swig文件中找到如下代码：123&lt;span class="with-love"&gt; &lt;i class="fa fa-star"&gt;&lt;/i&gt;&lt;/span&gt; 修改i标签的class属性fa-love，我这里改成了fa-star，其他图形未测过，有兴趣的朋友可以试试。 绑定域名绑定域名的思路如下： 在万网购买自己喜欢的域名（.com的会贵一点，.site和.xyz的相对便宜一些，有的只需要几块钱一年就可以） 解析DNS 在hexo中添加CNAME文件 购买域名之前没有买域名的时候我想使用网易云跟帖，发现在注册网易云跟帖的时候使用原来的域名提示“url已被使用”，这是因为网易云跟帖不认可二级域名，所以要自己买域名。我选择的是万网，阿里下面的。我选择了一个.site的域名，~按照官网的步骤一步一来就可以了~ 解析DNS购买完域名之后我们需要解析DNS地址，在管理控制台中的左侧有域名选项，然后找到你的域名，点击后面的“解析” 点击添加解析，记录类型选A或CNAME， A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。 在hexo中添加CNAME文件 接下来在你的hexo文件夹下source文件夹下新建一个CANME文件,里面加上你刚刚购买的域名比如我的cherryblog.site 然后你就可以hexo clean,hexo g，hexo d 发布你的博客看看效果啦~ 添加菜单页添加菜单页的思路（添加菜单页就是添加一个页面，有两种方式）：第一种是使用git命令hexo new page “photo” 就直接创建了d:\blog\source\photo\index.md文件，然后编辑index.md 文件就可以了~ 在hexo中menu下的内容都是新的页面我们可以通过hexo new page “pagename” 创建，hexo默认的页面只有home,archives,tags 三个，之后我们写的博文就是文章，通过hexo new “name” 创建的name.md 文件在根目录的source_posts 下，在每一个文章的头部，我们可以配置其tags或者categories内容，相当于文章是页面的下一级 ###在配置文件中添加menu索引路径我们可以在主题配置的_config文件下找到相应的字段，字段前加# 表示被注释掉，我们也可以自己添加menu的内容，比如我又新增了两个menulife 和photo这里添加的字段其实是加上文件索引的路径，这里hexo设置的根路径是hexo/source 接下来我们在这个根路径下建立相应的文件夹就可以实现点击mune跳转到相应的页面上了 在source文件添加menu文件夹我们需要在这个路径下自己建立对应的页面，比如说我新建了menulife 和photos，然后再source文件夹下面新建两个名字为life 和photo 的文件夹，里面添加一个index.md markdown文件，内容是类似这样的123456789101112123456title: photodate: 2017-04-04 22:14:07type: &quot;photo&quot;comments: false---啦啦啦~ 给menu添加icon如果只是上面的步骤，那么你可能会创建出一个新的页面，但是显示的效果会是这样： 怎么icon没有换？？？其实hexo中换icon是一个很简单的事情，因为hexo集成了FontAwsome 所以我们只需要在主题的配置文件中加入相应的icon名字即可 查找FontAwsome icon 这时候你想要换一个自己喜欢的icon怎么办，这就需要自己动手，丰衣足食了，你需要自己到FontAwsome官网，然后鼠标往下拉，在图标集中选择自己喜欢的icon，然后记住名字，保存在上面的menu_icon字段中就可以啦~ tips ：在字段中只需要填写icon-name后面跟的name即可，不需要加上前面的”icon-“ 在language添加zh-hans翻译字段上面的步骤完成之后你会发现，在你的博客首页显示的仍然是英文名，而我们想要有一个中文的名字，并且想要个性化定制我们的页面，我们可以在主题的language文件下的zh-hans（中文）语言包下增加相应的字段（做过翻译的童鞋应该都知道什么意思~）还可以修改其他的字段，这样就可以定制我们的博客了呢~ 在发表文章的时候添加对应的menu字段在我们写文章的时候只要在头部信息添加相应的字段就在tags页面和categories中显示相应的分类，例如:12345title: Git使用中的报错情况date: 2017-03-11 23:54:11tags: [git,实战经验] categories: git--- tags、categories都是支持数组的形式的，可以添加多个tags、categories。这样我们在tags、categories页面就可以看见相应的分类了。 添加头像要添加一个这个的头像要怎么操作呢，其实思路就是将你要上传的头像放在你的文件夹中，然后再配置文件中引用正确的路径即可，当然也可以上传绝对路径。在你的主题配置文件找到avatar字段，然后将你得图片路径写在后面，我是新建了一个uploads文件夹，将图片放在下面1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /uploads/avatar.png 设置网站logo跟设置头像其实是一个思路，都是在配置文件中引入正确的地址就可以了，不过网站的logo是对图片有要求的，我们需要在Favicon在线制作工具中制作32*32的.ico图片，然后放在source/images下面。然后在主题配置文件下添加主题配置文件中添加：favicon: images/favicon.ico 自定义样式不得不说next还是很人性化的，你可以个性化定制你的网站，你所有的改动（css）需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，所以只要你不想要你修改的样式，只需要删除这个文件夹就可以了，再也不用担心还原不回去了~ 炫酷动态背景只有两步就可以了添加修改代码next/layout/_layout.swig在&lt;/body&gt;之前加上123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif % 打开next/_config.yml，添加以下代码就可以了：12# Canvas-nestcanvas_nest: true 仿知乎动态背景如果你认为这样效果不够好，只能添加原生的js来仿知乎的登录界面做背景，这就需要修改模板来实现了。首先我们要知道next文件的结构，这样我们想改什么就知道在什么位置了~ 首先在主题文件的layout中的_layout.swigC:\Hexo\themes\next\layout_layout.swig中加入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;div class="bg_content"&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;/div&gt;'use strict'; var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;(); function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); &#125; return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self; &#125; function _inherits(subClass, superClass) &#123; if (typeof superClass !== "function" &amp;&amp; superClass !== null) &#123; throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; &#125; function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125; &#125; var Circle = function () &#123; function Circle(x, y) &#123; _classCallCheck(this, Circle); this.x = x; this.y = y; this.r = Math.random() * 10; this._mx = Math.random(); this._my = Math.random(); &#125; _createClass(Circle, [&#123; key: 'drawCircle', value: function drawCircle(ctx) &#123; ctx.beginPath(); //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。 ctx.arc(this.x, this.y, this.r, 0, 360); ctx.closePath(); ctx.fillStyle = 'rgba(204, 204, 204, 0.3)'; ctx.fill(); &#125; &#125;, &#123; key: 'drawLine', value: function drawLine(ctx, _circle) &#123; var dx = this.x - _circle.x; var dy = this.y - _circle.y; var d = Math.sqrt(dx * dx + dy * dy); if (d &lt; 150) &#123; ctx.beginPath(); ctx.moveTo(this.x, this.y); //起始点 ctx.lineTo(_circle.x, _circle.y); //终点 ctx.closePath(); ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)'; ctx.stroke(); &#125; &#125; &#125;, &#123; key: 'move', value: function move(w, h) &#123; this._mx = this.x &lt; w &amp;&amp; this.x &gt; 0 ? this._mx : -this._mx; this._my = this.y &lt; h &amp;&amp; this.y &gt; 0 ? this._my : -this._my; this.x += this._mx / 2; this.y += this._my / 2; &#125; &#125;]); return Circle; &#125;(); var currentCirle = function (_Circle) &#123; _inherits(currentCirle, _Circle); function currentCirle(x, y) &#123; _classCallCheck(this, currentCirle); return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y)); &#125; _createClass(currentCirle, [&#123; key: 'drawCircle', value: function drawCircle(ctx) &#123; ctx.beginPath(); //this.r = (this.r &lt; 14 &amp;&amp; this.r &gt; 1) ? this.r + (Math.random() * 2 - 1) : 2; this.r = 8; ctx.arc(this.x, this.y, this.r, 0, 360); ctx.closePath(); //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')' ctx.fillStyle = 'rgba(255, 77, 54, 0.6)'; ctx.fill(); &#125; &#125;]); return currentCirle; &#125;(Circle); window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d'); var w = canvas.width = canvas.offsetWidth; var h = canvas.height = canvas.offsetHeight; var circles = []; var current_circle = new currentCirle(0, 0); var draw = function draw() &#123; ctx.clearRect(0, 0, w, h); for (var i = 0; i &lt; circles.length; i++) &#123; circles[i].move(w, h); circles[i].drawCircle(ctx); for (j = i + 1; j &lt; circles.length; j++) &#123; circles[i].drawLine(ctx, circles[j]); &#125; &#125; if (current_circle.x) &#123; current_circle.drawCircle(ctx); for (var k = 1; k &lt; circles.length; k++) &#123; current_circle.drawLine(ctx, circles[k]); &#125; &#125; requestAnimationFrame(draw); &#125;; var init = function init(num) &#123; for (var i = 0; i &lt; num; i++) &#123; circles.push(new Circle(Math.random() * w, Math.random() * h)); &#125; draw(); &#125;; window.addEventListener('load', init(60)); window.onmousemove = function (e) &#123; e = e || window.event; current_circle.x = e.clientX; current_circle.y = e.clientY; &#125;; window.onmouseout = function () &#123; current_circle.x = null; current_circle.y = null; 在主题文件的C:\Hexo\themes\next\source\css_custom\custom.styl文件中加上css代码12345678910111213141516/*设置背景*/.bg_content&#123; position: fixed; top: 0; z-index: -1; width: 100%; height: 100%;&#125;#canvas&#123; width: 100%; height:100%;&#125;/*将头部背景变为透明*/.header&#123; background: transparent ;&#125; 添加网易云音乐我们可以直接在网易云音乐中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了layout/_macro/sidebar.swig 文件下 1234&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt;&lt;/div&gt; 然后就可以在侧边栏看见我的播放器了~ 网易云跟帖之前用的是多说，但是多说在2017年6月1日就关闭评论服务了= =，很忧伤，于是转到了网易云跟帖。由于最新版（5.1）版本的next已经集成了网易云跟帖，所以只需要在主题的设置文件中配置你的productKey就可以了。获取productKey也很简单，在官网网易云跟帖中注册，然后在获取代码&gt;通用代码中拿到productKey，之后在你的主题配置文件中的gentie_productKey字段后添加即可~ 添加Fork me on GitHub去网址https://github.com/blog/273-github-ribbons 挑选自己喜欢的样式，并复制代码，添加到themes\next\layout_layout.swig的body标签之内即可记得把里面的url换成自己的! hexo-wordcount实现统计功能wordcount可以实现字数统计，阅读时常还有总字数的统计功能只需要npm install hexo-wordcount –save 就可以安装wordcount插件，主要功能字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount安装完插件之后在主题的配置文件中开启该功能就可以~ 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true leancloud阅读次数统计next也集成了leancloud，在leancloud官网中注册账号等一步一步的操作就不说了哈~，我们主要是为了拿到app_key和app_id,然后在主题配置文件做一下配置123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: yourapp_id app_key: yourapp_key 然后再leancloud的控制台中的存储添加一个counter的class就可以检测到我们的浏览量了，同时在你文章的副标题也可以看到有阅读次数的显示 图床虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。 免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。 七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。 如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。 如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。 您还可以使用如下图床服务 FarBox，Dropbox，又拍云 主题优化Next主题很美观，个人也非常喜欢，但是一点令我们烦恼的就是主题加载的特别缓慢，那怎么优化呢？请参考一下两篇博文，作者已经总结的非常详细了，有需要的可以拜读一下，受益匪浅！ 提升Hexo的NexT主题加载速度 使用gulp精简hexo博客代码 分享我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加： 在hexo\themes\modernist\layout_partial\post下新建jiathis.ejs文件。注册加网获得你的分享代码，写入jiathis.ejs。 在hexo\themes\modernist\layout_partial\article.ejs中，添加&lt;%-partial(‘post/jiathis’)%&gt;。-分享服务还可以使用如下企业提供的技术加网，bShare，百度分享。 自定义挂件除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\themes\modernist\layout_widget\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\themes\modernist_config.yml中配置。12widgets: - myWidget 用上述方法可以添加新浪微博小挂件。 生成自己的微博组件。 添加hexo\themes\modernist\layout_widget\weibo.ejs文件。 配置hexo\themes\modernist_config.yml。 换机器你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。 我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。 2017年5月23号更新慢慢收集比较好的美化或者优化next主题的帖子 Hexo+NexT主题配置备忘 参考文献 利用Gitpage+hexo开发自己的博客 修改Hexo的Next主题 hexo你的博客 20分钟教你使用hexo搭建github博客 hexo + github + 多说 来搭建免费博客 利用swiftype为hexo添加站内搜索 博客搬迁记 - 从WordPress到Hexo 在hexo中无痛使用本地图片 手把手教你使用Travis CI自动部署你的Hexo博客到Github上 为Hexo博客生成sitemap 使用gulp精简hexo博客代码 单个GitHub帐号下添加多个GitHub Pages的相关问题 hexo你的博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵活方便的布局方式——弹性布局]]></title>
    <url>%2F2017%2F04%2F18%2F%E7%81%B5%E6%B4%BB%E6%96%B9%E4%BE%BF%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[本篇文章全部摘自阮一峰老师的Flex 布局教程。 之前我一直在用布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。最近在做百度前端技术学院的作业时发现很多人都在用Flex 布局，简单几行代码就能实现特殊的布局，所以我找了点资料，开始学习弹性布局。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。因为一山不容二虎，float、clear和vertical-align属性都是用来布局的属性，一旦使用flex，原来这些古老的属性不失效还留着干什么？ 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。各属性演示地址123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴（垂直轴）上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。1.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。1.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。1.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。1.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow,flex-shrink和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。1.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。1.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 五、Flex布局实例链接5.1 骰子的布局 5.2 网格布局 5.3 圣杯布局 5.4 输入框的布局 5.5 悬挂式布局 5.6 固定的底栏 5.7 流式布局]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>